<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++内存分配</title>
      <link href="/2023/06/07/C++%E5%9F%BA%E7%A1%80/C++%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
      <url>/2023/06/07/C++%E5%9F%BA%E7%A1%80/C++%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><p>内存分配与释放：</p><p> <code>new</code>：内存分配</p><p><code>delete/delete[]</code>：内存释放</p><p>程序代码也是存在于内存中</p><p>堆空间与栈空间是数据空间</p><p>堆空间从低往上走</p><p>栈空间从高往低走</p><h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><p>浅拷贝：只拷贝栈内存，也就是说只拷贝了栈内存中的堆内存的地址，最终拷贝的两个对象指向同一个堆内存地址</p><p>深拷贝：拷贝栈内存数据，但是栈内存中存储堆内存地址部分却是重新申请的堆内存的空间地址，堆内存只拷贝数据内容，而内存空间是重新申请生成的</p>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++基础语法</title>
      <link href="/2023/06/07/C++%E5%9F%BA%E7%A1%80/C++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/06/07/C++%E5%9F%BA%E7%A1%80/C++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="C-基础语法"><a href="#C-基础语法" class="headerlink" title="C++基础语法"></a>C++基础语法</h1><p><strong>构造函数与析构函数</strong></p><ol><li>一个类中析构函数只能有一个，而构造函数可以有很多个</li><li>析构函数没有函数参数、没有返回值、没有返回类型</li><li>由于没有函数参数，所以不能被重载</li><li>构造函数在类的构建时调用，析构函数在类的声明周期结束时调用</li></ol><p>Test.h文件</p><pre><code class="c++">#ifdef _TEST_H_ #defind _TEST_H_ #include &lt;iostream&gt;using namespace sthnamespace test&#123;    class Test&#123;        public:            Test()&#123;                this.sex=0;                this.sex=0L;            &#125; //构造函数            ~Test()&#123;&#125; //析构函数        public:            void setSex(int sex); //公共方法            void setPhone(long phone);             int getSex();            long getPhone();        private:            int sex; //私有属性            long phone;    &#125;;&#125; //namespace#endif //_TEST_H_</code></pre><p>Test.cpp文件</p><pre><code class="c++">#include &lt;iostream&gt;#include &quot;Test.h&quot;namespace test&#123;    void Test::setSex(int s)&#123;        sex = s;    &#125;    void Test::setPhone(long p)&#123;        phone = p;    &#125;    int Test::getSex()&#123;        return sex;    &#125;    long Test::getPhone()&#123;        return phone;    &#125;&#125;</code></pre><p><strong>名存空间</strong></p><p><code>using namespace &#39;Name&#39;</code>：选择名存空间</p><p><code>namespace &#39;Name&#39;</code>：创建名存空间关键字</p>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++语法_继承</title>
      <link href="/2023/06/07/C++%E5%9F%BA%E7%A1%80/C++%E8%AF%AD%E6%B3%95_%E7%BB%A7%E6%89%BF/"/>
      <url>/2023/06/07/C++%E5%9F%BA%E7%A1%80/C++%E8%AF%AD%E6%B3%95_%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p><strong>Fight.h</strong>文件</p><pre><code class="c++">#ifdel _CLIENT_TEST_H_#default _CLIENT_TEST_H_#include &lt;iostream&gt;#include &quot;Test.h&quot;namespace fight&#123;    class Fight: public Test&#123;      public:        Figint()&#123;            wea = 1;        &#125;        ~Fight()&#123;        &#125;        private:            int wea;        public:            void setWea(int w);            int getWea();    &#125;;&#125; //namespace#endif // _CLIENT_FIGht_H_</code></pre><p><strong>Feight.cpp</strong>文件</p><pre><code class="c++">#include &lt;iostream&gt;#include &quot;Fight.h&quot;namespace fight&#123;    void Fight::setWea(w)&#123;        wea = w;    &#125;    int Fight::getWea()&#123;        return wea;    &#125;&#125;</code></pre><p><strong>调用</strong></p><pre><code class="c++">#include &lt;iostream&gt;#include &quot;Fight.h&quot;int main(int argc, char* agev[])&#123;    fight::Fight&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO与NIO</title>
      <link href="/2023/06/07/Java%E5%9F%BA%E7%A1%80/IO%E4%B8%8ENIO/"/>
      <url>/2023/06/07/Java%E5%9F%BA%E7%A1%80/IO%E4%B8%8ENIO/</url>
      
        <content type="html"><![CDATA[<h1 id="IO与NIO"><a href="#IO与NIO" class="headerlink" title="IO与NIO"></a>IO与NIO</h1><h3 id="1、阻塞与非阻塞"><a href="#1、阻塞与非阻塞" class="headerlink" title="1、阻塞与非阻塞"></a>1、阻塞与非阻塞</h3><p>阻塞与非阻塞是描述进程在访问某个资源时，数据是否准备就绪的的一种处理方式。当数据没有准备就绪时：</p><ul><li>阻塞：线程持续等待资源中数据准备完成，直到返回响应结果。</li><li>非阻塞：线程直接返回结果，不会持续等待资源准备数据结束后才响应结果。</li></ul><h3 id="2、同步与异步"><a href="#2、同步与异步" class="headerlink" title="2、同步与异步"></a>2、同步与异步</h3><ul><li>同步与异步是指访问数据的机制，同步一般指主动请求并等待IO操作完成的方式。</li><li>异步则指主动请求数据后便可以继续处理其它任务，随后等待IO操作完毕的通知。</li></ul><p>老王烧开水：<br> 1、普通水壶煮水，站在旁边，主动的看水开了没有？同步的阻塞<br> 2、普通水壶煮水，去干点别的事，每过一段时间去看看水开了没有，水没开就走人。 同步非阻塞<br> 3、响水壶煮水，站在旁边，不会每过一段时间主动看水开了没有。如果水开了，水壶自动通知他。 异步阻塞<br> 4、响水壶煮水，去干点别的事，如果水开了，水壶自动通知他。异步非阻塞</p><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="1、传统BIO模型"><a href="#1、传统BIO模型" class="headerlink" title="1、传统BIO模型"></a>1、传统BIO模型</h4><p>传统BIO是一种同步的阻塞IO，IO在进行读写时，该线程将被阻塞，线程无法进行其它操作。<br> IO流在读取时，会阻塞。直到发生以下情况：1、有数据可以读取。2、数据读取完成。3、发生异常</p><h4 id="2、伪异步IO模型"><a href="#2、伪异步IO模型" class="headerlink" title="2、伪异步IO模型"></a>2、伪异步IO模型</h4><p>以传统BIO模型为基础，通过线程池的方式维护所有的IO线程，实现相对高效的线程开销及管理。</p><h4 id="3、NIO模型"><a href="#3、NIO模型" class="headerlink" title="3、NIO模型"></a>3、NIO模型</h4><p>NIO（JDK1.4）模型是一种同步非阻塞IO，主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector（多路复用器）。传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(多路复用器)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。<br> NIO和传统IO（一下简称IO）之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。<br> IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p><h4 id="NIO优点："><a href="#NIO优点：" class="headerlink" title="NIO优点："></a>NIO优点：</h4><ol><li>通过Channel注册到Selector上的状态来实现一种客户端与服务端的通信。</li><li>Channel中数据的读取是通过Buffer , 一种非阻塞的读取方式。</li><li>Selector 多路复用器  单线程模型，  线程的资源开销相对比较小。</li></ol><h4 id="Channel-通道"><a href="#Channel-通道" class="headerlink" title="Channel(通道)"></a>Channel(通道)</h4><p>传统IO操作对read()或write()方法的调用，可能会因为没有数据可读&#x2F;可写而阻塞，直到有数据响应。也就是说读写数据的IO调用，可能会无限期的阻塞等待，效率依赖网络传输的速度。最重要的是在调用一个方法前，无法知道是否会被阻塞。</p><p>NIO的Channel抽象了一个重要特征就是可以通过配置它的阻塞行为，来实现非阻塞式的通道。</p><p>Channel是一个双向通道，与传统IO操作只允许单向的读写不同的是，NIO的Channel允许在一个通道上进行读和写的操作。</p><p>FileChannel:文件</p><p>SocketChannel:</p><p>ServerSocketChannel:</p><p>DatagramChannel: UDP</p><h4 id="Buffer-缓冲区"><a href="#Buffer-缓冲区" class="headerlink" title="Buffer(缓冲区)"></a>Buffer(缓冲区)</h4><p>Bufer顾名思义，它是一个缓冲区，实际上是一个容器，一个连续数组。Channel提供从文件、网络读取数据的渠道，但是读写的数据都必须经过Buffer。</p><p><img src="https://upload-images.jianshu.io/upload_images/13449209-300fd48a7251c327.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/654/format/webp" alt="img"></p><p>Buffer(缓冲区)</p><p>Buffer缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该模块内存。为了理解Buffer的工作原理，需要熟悉它的三个属性：capacity、position和limit。</p><p>position和limit的含义取决于Buffer处在读模式还是写模式。不管Buffer处在什么模式，capacity的含义总是一样的。见下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/13449209-d261cbcb9b9ed88f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/506/format/webp" alt="img"></p><p>capacity、position和limit</p><ul><li>capacity：作为一个内存块，Buffer有固定的大小值，也叫作“capacity”，只能往其中写入capacity个byte、long、char等类型。一旦Buffer满了，需要将其清空（通过读数据或者清楚数据）才能继续写数据。</li><li>position：当你写数据到Buffer中时，position表示当前的位置。出事的position值为0，当写入一个字节数据到Buffer中后，position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity-1。当读取数据时，也是从某个特定位置读，讲Buffer从写模式切换到读模式，position会被重置为0。当从Buffer的position处读取一个字节数据后，position向前移动到下一个可读的位置。</li><li>limit：在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。 写模式下，limit等于Buffer的capacity。当切换Buffer到读模式时， limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是position）</li></ul><h4 id="Buffer的分配："><a href="#Buffer的分配：" class="headerlink" title="Buffer的分配："></a>Buffer的分配：</h4><p>对Buffer对象的操作必须首先进行分配，Buffer提供一个allocate(int capacity)方法分配一个指定字节大小的对象。<br> 向Buffer中写数据：写数据到Buffer中有两种方式：<br> 1.从channel写到Buffer</p><pre><code class="cpp">int bytes = channel.read(buf); //将channel中的数据读取到buf中</code></pre><p>2.通过Buffer的put()方法写到Buffer</p><pre><code class="csharp">buf.put(byte); //将数据通过put()方法写入到buf中</code></pre><ul><li>flip()方法：将Buffer从写模式切换到读模式，调用flip()方法会将position设置为0，并将limit设置为之前的position的值。<br> 从Buffer中读数据：从Buffer中读数据有两种方式：<br> 1.从Buffer读取数据到Channel</li></ul><pre><code class="cpp">int bytes = channel.write(buf); //将buf中的数据读取到channel中</code></pre><p>2.通过Buffer的get()方法读取数据</p><pre><code class="csharp">byte bt = buf.get(); //从buf中读取一个byte</code></pre><ul><li>rewind()方法：Buffer.rewind()方法将position设置为0，使得可以重读Buffer中的所有数据，limit保持不变。</li><li>clear()与compact()方法：一旦读完Buffer中的数据，需要让Buffer准备好再次被写入，可以通过clear()或compact()方法完成。如果调用的是clear()方法，position将被设置为0，limit设置为capacity的值。但是Buffer并未被清空，只是通过这些标记告诉我们可以从哪里开始往Buffer中写入多少数据。如果Buffer中还有一些未读的数据，调用clear()方法将被”遗忘 “。compact()方法将所有未读的数据拷贝到Buffer起始处，然后将position设置到最后一个未读元素的后面，limit属性依然设置为capacity。可以使得Buffer中的未读数据还可以在后续中被使用。</li><li>mark()与reset()方法：通过调用Buffer.mark()方法可以标记一个特定的position，之后可以通过调用Buffer.reset()恢复到这个position上。</li></ul><h4 id="Selector-多路复用器"><a href="#Selector-多路复用器" class="headerlink" title="Selector(多路复用器)"></a>Selector(多路复用器)</h4><p>Selector与Channel是相互配合使用的，将Channel注册在Selector上之后，才可以正确的使用Selector，但此时Channel必须为非阻塞模式。Selector可以监听Channel的四种状态（Connect、Accept、Read、Write），当监听到某一Channel的某个状态时，才允许对Channel进行相应的操作。</p><ul><li>Connect：某一个客户端连接成功后</li><li>Accept：准备好进行连接</li><li>Read:可读</li><li>Write:可写</li></ul><p>作者：林亚希<br>链接：<a href="https://www.jianshu.com/p/5bb812ca5f8e">https://www.jianshu.com/p/5bb812ca5f8e</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Jar后台运行</title>
      <link href="/2023/06/07/Java%E5%9F%BA%E7%A1%80/Jar%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/"/>
      <url>/2023/06/07/Java%E5%9F%BA%E7%A1%80/Jar%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="JAR后台运行"><a href="#JAR后台运行" class="headerlink" title="JAR后台运行"></a>JAR后台运行</h1><p>保存后台运行，且把日志信息打印输出到指定的文件中</p><p>jar name：jar包的名字</p><p>log file：完整的日志文件路径，包括日志文件</p><pre><code class="shell">nohup java -jar &#39;jar name&#39; &gt; &#39;log file&#39; &amp;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript获取视频流且回显</title>
      <link href="/2023/06/07/Java%E5%9F%BA%E7%A1%80/JavaScript%E8%8E%B7%E5%8F%96%E8%A7%86%E9%A2%91%E6%B5%81%E4%B8%94%E5%9B%9E%E6%98%BE/"/>
      <url>/2023/06/07/Java%E5%9F%BA%E7%A1%80/JavaScript%E8%8E%B7%E5%8F%96%E8%A7%86%E9%A2%91%E6%B5%81%E4%B8%94%E5%9B%9E%E6%98%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript获取视频流且回显"><a href="#JavaScript获取视频流且回显" class="headerlink" title="JavaScript获取视频流且回显"></a>JavaScript获取视频流且回显</h1><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;style&gt;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;video id=&quot;video&quot; width=&quot;640&quot; height=&quot;480&quot; autoplay=&quot;autoplay&quot;&gt;&lt;/video&gt;        &lt;br/&gt;        &lt;button id=&quot;snap&quot;&gt;截取图像&lt;/button&gt;&lt;button id=&quot;start&quot;&gt;开始录制&lt;/button&gt;&lt;button id=&quot;stop&quot;&gt;停止录制&lt;/button&gt;        &lt;br/&gt;        &lt;canvas id=&quot;canvas&quot; width=&quot;640&quot; height=&quot;480&quot;&gt;&lt;/canvas&gt;    &lt;/body&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        let videoView = document.getElementById(&quot;video&quot;);        let buttonView = document.getElementById(&quot;snap&quot;);        let startButton = document.getElementById(&quot;start&quot;);        let stopButton = document.getElementById(&quot;stop&quot;);        let canvasView = document.getElementById(&quot;canvas&quot;);        navigator.mediaDevices.getDisplayMedia(&#123;            video: &#123;                width: 640,                height: 480            &#125;,            audio: true        &#125;).then(stream =&gt; &#123;            console.log(&quot;摄像头打开成功！！！&quot;, stream);            //以ID为基准,video控件的ID是什么此处的video就是什么            video.srcObject = stream;            // 创建下载对象            let mediaRecorder = new MediaRecorder(stream, &#123;                audioBitsPerSecond: 128000, // 音频码率                videoBitsPerSecond: 100000, // 视频码率                mimeType: &#39;video/webm;codecs=h264&#39; // 编码格式            &#125;);            startButton.onclick = (e =&gt; &#123;                console.log(&quot;触发下载按钮！！！&quot;, e)                mediaRecorder.start(5000);            &#125;);            stopButton.onclick = (e =&gt; &#123;                console.log(&quot;触发结束按钮！！！&quot;, e)                mediaRecorder.stop();            &#125;);            mediaRecorder.ondataavailable = (e =&gt; &#123;                console.log(&quot;开始下载&quot;)                // 下载视频                var blob = new Blob([e.data], &#123; &#39;type&#39; : &#39;video/mp4&#39; &#125;)                let a = document.createElement(&#39;a&#39;)                a.href = URL.createObjectURL(blob)                a.download = `test.mp4`                a.click()            &#125;);            //监听流录入失败            video.onerror = (err =&gt; &#123;                console.log(&quot;加载错误！！！&quot;, err);            &#125;);            //监听流录入成功            video.onloadeddata = (e =&gt; &#123;                console.log(&quot;加载成功！！！&quot;, e);            &#125;);        &#125;).catch(stream =&gt; &#123;            console.log(&quot;摄像头打开失败！！！&quot;, stream);        &#125;);        //给button按钮设置一个点击事件监听        buttonView.onclick = function() &#123;            //获取画布的2d上下文，然后把视频内的一帧绘制到画布上            canvasView.getContext(&quot;2d&quot;).drawImage(videoView, 0, 0, 640, 480)        &#125;    &lt;/script&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java动态代理和反射实现字段名栈深寻值</title>
      <link href="/2023/06/07/Java%E5%9F%BA%E7%A1%80/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%B0%84%E5%AE%9E%E7%8E%B0%E5%AD%97%E6%AE%B5%E5%90%8D%E6%A0%88%E6%B7%B1%E5%AF%BB%E5%80%BC/"/>
      <url>/2023/06/07/Java%E5%9F%BA%E7%A1%80/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%B0%84%E5%AE%9E%E7%8E%B0%E5%AD%97%E6%AE%B5%E5%90%8D%E6%A0%88%E6%B7%B1%E5%AF%BB%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-动态代理与反射实现属性名称栈深寻值"><a href="#Java-动态代理与反射实现属性名称栈深寻值" class="headerlink" title="Java 动态代理与反射实现属性名称栈深寻值"></a>Java 动态代理与反射实现属性名称栈深寻值</h1><p>原因：对方法做动态代理，并且动态代理依赖方法形参的某些属性值，而属性值可能是对象的属性的属性，形成一个栈深寻找</p><p>思路：</p><ol><li>使用Map对所有的形参进行名称和形参对象的映射</li><li>把所指定的属性字符串按照指定规则切割载入队列</li><li>利用队列出栈的特性，对第一个参数名称做map的 key value 值匹配，找到对应的参数对象</li><li>对找到的参数对象做反射解析，利用递归做栈深的属性匹配和值查找</li><li>在队列没有匹配字符串的时候，所拿到的值就是我们最终需要的值，直接强转为字符串类型</li></ol><p>代码</p><pre><code class="java">// 参数对象class User &#123;    private String username;    private String phone;    private String birthday;    private User user;        public User(String username, String phone, User user) &#123;        this.username = username;        this.phone = phone;        this.user = user;    &#125;// 由于JDK的Proxy代理只能代理接口，所以需要创建一个接口interface Ts &#123;    void a(User user);&#125;// 执行信息体class Test implements Ts &#123;    @Override    public void a(User user) &#123;        System.out.println(&quot;主要信息执行&quot;);    &#125;&#125;// 执行代码Test test = new Test();HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(10);LinkedBlockingQueue&lt;String&gt; queue = new LinkedBlockingQueue&lt;&gt;(Arrays.asList(&quot;user.user.username&quot;.split(&quot;\\.&quot;)));Ts ts = (Ts) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),            Test.class.getInterfaces(), (Object proxy, Method method, Object[] args1) -&gt; &#123;                // 初始化map                Parameter[] parameters = method.getParameters();                for (int i = 0; i &lt; parameters.length; i++) &#123;                    map.put(parameters[i].getName(), args1[i]);                &#125;                // 匹配参数对象                Object o = map.get(queue.poll());                // 递归寻值                while (queue.size() &gt; 0) &#123;                    o = diGui(queue.poll(), o);                &#125;                String result = (String) o;                System.out.println(&quot;lock&quot; + result);                Object invoke = method.invoke(test, args1);                System.out.println(&quot;unlock&quot; + result);                map.clear();                queue.clear();                return invoke;            &#125;);    ts.a(new User(&quot;huang&quot;, &quot;153&quot;, new User(&quot;Q202111222256489&quot;, &quot;158&quot;)));    // 递归寻值public static Object diGui(String fieldName, Object o) throws NoSuchFieldException, IllegalAccessException &#123;    Field field = o.getClass().getDeclaredField(fieldName);    field.setAccessible(true);    return field.get(o);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java反射对象内容</title>
      <link href="/2023/06/07/Java%E5%9F%BA%E7%A1%80/Java%E5%8F%8D%E5%B0%84%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AE%B9/"/>
      <url>/2023/06/07/Java%E5%9F%BA%E7%A1%80/Java%E5%8F%8D%E5%B0%84%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<p>调用方式</p><pre><code class="java">MonthlyCardOrderParam param = new MonthlyCardOrderParam();        param.setRefundStatus(1);        notNullCheck(param, NotNull.class, &quot;message&quot;);        notNullCheck(param, NotNull.class, new INotNullParamCheck&lt;NotNull&gt;() &#123;            @Override            public void check(String attributeName, Object attributeValue, NotNull annotation) &#123;                System.out.println(attributeName+&quot;[&quot;+attributeValue+&quot;] -&gt;&quot;+annotation.message());            &#125;        &#125;);</code></pre><hr><p>方法一</p><pre><code class="java">/**     * 判定某个对象的属性值是否为空，通过注解来判定     * 主要用在非 Controller 上接受参数的时候     *     * @param param 所要判定的对象     * @param annotationClass 所要判定的注解     * @param func 所执行注解方法的名称     * @param &lt;E&gt; 判定对象泛型     * @param &lt;T&gt; 注解方法泛型 Annotation 的实例     * @throws IllegalAccessException 获取字段的异常     * @throws NoSuchMethodException 找不到方法异常     * @throws InvocationTargetException 反射执行方法异常     */    public static &lt;E,T extends Annotation&gt; void notNullCheck (E param, Class&lt;T&gt; annotationClass, String func)            throws IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;        // 获取 Field 对象：也就是对象的所有属性对象        Field[] fields = param.getClass().getDeclaredFields();        for (Field field : fields) &#123;            // 设置 private 属性可读            field.setAccessible(true);            // 获取当前属性上的某个注解，并且做空值判断            T annotation = field.getAnnotation(annotationClass);            if (annotation!=null)&#123;                // 获取当前属性的对应值                if (field.get(param) == null)&#123;                    if (func!=null)&#123;                        System.out.println(annotationClass.getMethod(func).invoke(annotation));                    &#125;                &#125;            &#125;        &#125;    &#125;</code></pre><p>方法二</p><pre><code class="java">/**     * 校验回调接口     * @param &lt;T&gt;     */    interface INotNullParamCheck&lt;T&gt;&#123;        /**         * 校验回调         *         * @param attributeName 属性名称         * @param attributeValue 参数         * @param annotation 注解对象         */        void check(String attributeName,Object attributeValue,T annotation);    &#125;    /**     * 为空校验     * @param param 校验对象     * @param annotationClass 查询的接口 Class     * @param notNullParamCheck 校验回调接口     * @param &lt;E&gt; 参数对象泛型     * @param &lt;T&gt; 查询接口泛型     * @throws IllegalAccessException 找不到属性异常     */    public static &lt;E, T extends Annotation&gt; void notNullCheck(E param, Class&lt;T&gt; annotationClass,INotNullParamCheck&lt;T&gt; notNullParamCheck)            throws IllegalAccessException &#123;        Field[] fields = param.getClass().getDeclaredFields();        for (Field field : fields) &#123;            field.setAccessible(true);            T annotation = field.getAnnotation(annotationClass);            Object item = field.get(param);            if (annotation!=null) &#123;                System.out.println(item);                notNullParamCheck.check(field.getName(),item,annotation);            &#125;        &#125;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java的ArrayList</title>
      <link href="/2023/06/07/Java%E5%9F%BA%E7%A1%80/Java%E7%9A%84ArrayList/"/>
      <url>/2023/06/07/Java%E5%9F%BA%E7%A1%80/Java%E7%9A%84ArrayList/</url>
      
        <content type="html"><![CDATA[<h1 id="Collection中的List中的ArrayList"><a href="#Collection中的List中的ArrayList" class="headerlink" title="Collection中的List中的ArrayList"></a>Collection中的List中的ArrayList</h1><p><code>DEFAULT_CAPACITY = 10;</code>默认大小</p><p>ArrayList的初始化操作为，如果你没有传入参数就是赋予一个默认的Object数组对象，然后在添加第一个元素的时候进行扩容，如果我们传入了创建大小的参数，那么会做大小判定，如果为0就赋予一个空的对象，也是一个Object数组，还有如果参数是Collection对象等等情况。</p><pre><code class="Java">private void grow(int minCapacity) &#123;        // overflow-conscious code        int oldCapacity = elementData.length;        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);        if (newCapacity - minCapacity &lt; 0)            newCapacity = minCapacity;        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)            newCapacity = hugeCapacity(minCapacity);        // minCapacity is usually close to size, so this is a win:        elementData = Arrays.copyOf(elementData, newCapacity);    &#125;</code></pre><p>在这里有一行重要的代码即使<code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code>这里得到的新的容量大小为原大小的1.5倍，是因为使用了向右唯一了一个，相当于除以了2，也就是加上了0.5倍的大小</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java反射根据方法名获取参数名</title>
      <link href="/2023/06/07/Java%E5%9F%BA%E7%A1%80/Java%E5%8F%8D%E5%B0%84%E6%A0%B9%E6%8D%AE%E6%96%B9%E6%B3%95%E5%90%8D%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E5%90%8D/"/>
      <url>/2023/06/07/Java%E5%9F%BA%E7%A1%80/Java%E5%8F%8D%E5%B0%84%E6%A0%B9%E6%8D%AE%E6%96%B9%E6%B3%95%E5%90%8D%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-反射-根据方法名获取参数名"><a href="#Java-反射-根据方法名获取参数名" class="headerlink" title="Java 反射 根据方法名获取参数名"></a>Java 反射 根据方法名获取参数名</h1><p>首先实现一个可序列化的Function集成接口</p><pre><code class="java">interface CustomFunction&lt;T, R&gt; extends Function&lt;T, R&gt;, Serializable &#123;&#125;</code></pre><p>再构建一个Student类，作为本次获取的测试Entity</p><pre><code class="java">static class Student implements Serializable &#123;    private static final long serialVersionUID = -5681957118855943196L;    private Integer age;    private String studentName;    public Student(Integer age, String studentName) &#123;        this.age = age;        this.studentName = studentName;    &#125;    public void setAge(Integer age) &#123;        this.age = age;    &#125;    public void setStudentName(String studentName) &#123;        this.studentName = studentName;    &#125;    public Integer getAge() &#123;        return age;    &#125;    public String getStudentName() &#123;        return studentName;    &#125;&#125;</code></pre><p>使用反射获取当前方法的名称，然后切割出对应的属性名称，就是获取get的方法名称，再把get的切割，把第一个字母大写</p><pre><code class="java">public static &lt;T, R&gt; String functionToProperStr(CustomFunction&lt;T, R&gt; function) throws Exception &#123;    Method writeReplace = function.getClass().getDeclaredMethod(&quot;writeReplace&quot;);    boolean accessible = writeReplace.isAccessible();    writeReplace.setAccessible(true);    SerializedLambda serializedLambda = (SerializedLambda) writeReplace.invoke(function);    writeReplace.setAccessible(accessible);    String fieldName = serializedLambda.getImplMethodName().substring(&quot;get&quot;.length());    fieldName = fieldName.replaceFirst(String.valueOf(fieldName.charAt(0)), String.valueOf(fieldName.charAt(0)).toLowerCase());    return fieldName;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java的HashMap</title>
      <link href="/2023/06/07/Java%E5%9F%BA%E7%A1%80/Java%E7%9A%84HashMap/"/>
      <url>/2023/06/07/Java%E5%9F%BA%E7%A1%80/Java%E7%9A%84HashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="关于集合中的hashmap"><a href="#关于集合中的hashmap" class="headerlink" title="关于集合中的hashmap"></a>关于集合中的hashmap</h1><p>关于tableSizeFor方法：Returns a power of two size for the given target capacity.返回当前数的最小二次幂</p><p>默认初始化的hashmap大小为16个大小，默认的负载系数为0.75<br>负载系数的计算公式：f &#x3D; 当前实际数目 &#x2F; hashmap总数目<br>也就是说当存入的数目大于等于总容量乘以负载系数的时候就会进扩容操作<br>如果负载系数大于或者等于了规定的负载系数，则会进行hashmap的扩容</p><p>get、put：先求hash值，然后右移16位做高位对比，求出hash之后通过hash找到指定的桶，当发生hash冲突的时候，会在同一个桶内存在多个节点，当我们的节点数超过了8个的时候，会做红黑树与链表的转换</p><pre><code class="Java">if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st   treeifyBin(tab, hash); //红黑树转换 break;&#125;</code></pre><p>TREEIFY_THRESHOLD默认值为8，为树型阈值，在8以内使用链表，在8以外使用红黑树</p><p>hash表里面所用的hashcode方法中的<code>Objects.hashCode(key)</code>，都取自于Object的hashcode方法，而Object的hashcode方法的标注是<code>public native int hashCode();</code>，native是java与其他编程语言进行交互的声明保留字段，也就是说这里的hashCode()方法其实调用的是C&#x2F;C++的hashCode的计算hash值</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java的Vector</title>
      <link href="/2023/06/07/Java%E5%9F%BA%E7%A1%80/Java%E7%9A%84Vector/"/>
      <url>/2023/06/07/Java%E5%9F%BA%E7%A1%80/Java%E7%9A%84Vector/</url>
      
        <content type="html"><![CDATA[<h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><p>vector的存储单元是数组，在没有指定默认大小的时候，默认初始大小是10，vector和ArrayList的最大区别在线程安全</p><p>构造方法有：</p><ul><li>全参数构造：1、初始化大小，2、扩容大小</li><li>单参构造：初始化大小，扩容大小为0</li><li>无参构造：</li><li>集合参数：传入一个Collection的子类，进行拷贝创建</li></ul><p>扩容操作：Vector的扩容大小是基于扩容大小参数的，如果扩容参数为0就成倍扩大，否则就按照参数</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java计算文件MD5</title>
      <link href="/2023/06/07/Java%E5%9F%BA%E7%A1%80/Java%E8%AE%A1%E7%AE%97%E6%96%87%E4%BB%B6MD5/"/>
      <url>/2023/06/07/Java%E5%9F%BA%E7%A1%80/Java%E8%AE%A1%E7%AE%97%E6%96%87%E4%BB%B6MD5/</url>
      
        <content type="html"><![CDATA[<h1 id="计算文件的MD5"><a href="#计算文件的MD5" class="headerlink" title="计算文件的MD5"></a>计算文件的MD5</h1><pre><code class="java">public String md5(File file)&#123;        try &#123;            MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);            FileInputStream fileInputStream = new FileInputStream(file);            ByteArrayOutputStream stream = new ByteArrayOutputStream();            byte [] bytes = new byte[1024];            int read = 0;            while ((read=(fileInputStream.read(bytes)))!=-1)&#123;                stream.write(bytes,0,read);            &#125;            fileInputStream.close();            stream.close();            byte[] byteArray = stream.toByteArray();            md5.update(byteArray);            byte[] digest = md5.digest();            BigInteger bigInteger = new BigInteger(1,digest);            //生成MD5的进制数            return bigInteger.toString(16);        &#125; catch (NoSuchAlgorithmException | IOException e) &#123;            throw new ApplicationException(CodeType.SERVICE_ERROR, &quot;MD5转换失败&quot;);        &#125;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Jvm内存结构</title>
      <link href="/2023/06/07/Java%E5%9F%BA%E7%A1%80/Jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
      <url>/2023/06/07/Java%E5%9F%BA%E7%A1%80/Jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a><code>JVM</code>内存结构</h1><p>Java虚拟机分为五个部分：程序计数器、Java虚拟机栈、本地方法栈、堆、方法区</p><p><img src="https://camo.githubusercontent.com/9ab34e9114814b84731635c2b2cc2abd0084edc44d220602948742aa8ad83340/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f646f6f63732f6a766d406d61696e2f696d616765732f6a766d2d6d656d6f72792d7374727563747572652e6a7067"></p><p><strong>程序计数器（PC寄存器）</strong></p><p>定义：</p><ul><li>程序计数器是一块较小内存空间，是当前线程执行那条字节码的所在地址，如果当前线程正在执行的是一个本地方法（Native），那么此程序计数器为Undefined。</li></ul><p>作用：</p><ul><li>字节码解读器通过切换程序计数器的顺序，来改变当前执行的指令，从而实现程序的流程控制</li><li>在多线程的情况下，线程计数器记录的是当前线程的执行位置，当线程切换回来的时候，就知道上次线程的执行位置</li></ul><p>特点：</p><ul><li>是一块较小的空间</li><li>线程私有，每个线程都有自己的程序计数器</li><li>生命周期随着线程的诞生而诞生，随着线程的销毁而销毁</li><li>是唯一一个不会出现<code>OutOfMemoryError</code>的内存区域</li></ul><p><strong>Java虚拟机栈（Java栈）</strong></p><p><img src="https://camo.githubusercontent.com/109d4eff5b60971060cef6cb1e7923e274771d5e1655e0e5aabaf40df9f9aa6a/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f646f6f63732f6a766d406d61696e2f696d616765732f6a766d2d737461636b2e6a7067"></p><p>定义：</p><ul><li>Java虚拟机栈是描述Java方法运行过程的内存模型，Java虚拟机栈会为每一个即将运行的方法创建一块帧栈内存，用于存放该方法运行过程中的一些信息，如局部变量表、操作数栈、动态链接、方法出口信息</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Jvm垃圾收集器</title>
      <link href="/2023/06/07/Java%E5%9F%BA%E7%A1%80/Jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
      <url>/2023/06/07/Java%E5%9F%BA%E7%A1%80/Jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>新生代垃圾收集器</p><p>Serial垃圾收集器：是单线程的收集器，并且在垃圾收集的时候需要暂停所有的用户线程</p><p>ParNew垃圾收集器：是Serial收集器的多线程版本，在垃圾收集的时候一样需要暂停所有的用户线程，在多CPU条件下性能比Serial收集器要好，但是由于线程切换需要损耗一定的资源，所以在单CPU的环境下，性能不如Serial好</p><p>Parallel Scavenge垃圾收集器：</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Jvm虚拟机</title>
      <link href="/2023/06/07/Java%E5%9F%BA%E7%A1%80/Jvm%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/2023/06/07/Java%E5%9F%BA%E7%A1%80/Jvm%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM虚拟机"><a href="#JVM虚拟机" class="headerlink" title="JVM虚拟机"></a>JVM虚拟机</h1><p>指针碰撞（bump the pointer）： 指在分配内存的时候，由于堆空间的内存是整齐规划的，一边是使用的内存，一边是空闲的内存，中间由指针分开，在移动指针进行内存分配的时候叫做内存分配</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二维码生成</title>
      <link href="/2023/06/07/Java%E5%9F%BA%E7%A1%80/%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%94%9F%E6%88%90/"/>
      <url>/2023/06/07/Java%E5%9F%BA%E7%A1%80/%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Zxing"><a href="#Zxing" class="headerlink" title="Zxing"></a>Zxing</h1><h3 id="POM文件的引入"><a href="#POM文件的引入" class="headerlink" title="POM文件的引入"></a>POM文件的引入</h3><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;    &lt;artifactId&gt;javase&lt;/artifactId&gt;    &lt;version&gt;3.3.3&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="后端Controller的port代码"><a href="#后端Controller的port代码" class="headerlink" title="后端Controller的port代码"></a>后端Controller的port代码</h3><pre><code class="java"> @PortMapping(&quot;/qrCode/&quot;)    public Object qrCode(@RequestParam(&quot;centext&quot;)String centext, HttpServletResponse response, HttpServletRequest request)&#123;        Map&lt;EncodeHintType, Object&gt; hints = new HashMap&lt;&gt;(3);        hints.put(EncodeHintType.CHARACTER_SET,&quot;UTF-8&quot;);        hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H);        hints.put(EncodeHintType.MARGIN,1);        try &#123;            response.setContentType(&quot;image/png;charset=UTF-8&quot;);            ServletOutputStream outputStream = response.getOutputStream();            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();            BitMatrix bitMatrix = new MultiFormatWriter().encode(context, BarcodeFormat.QR_CODE, 200, 200, hints);            MatrixToImageWriter.writeToStream(bitMatrix,&quot;png&quot;,byteArrayOutputStream);   //编码格式转换，由于前端用ajax设置img标签的src属性需要  response.getOutputStream().write(Base64.encodeBase64(byteArrayOutputStream.toByteArray()));            outputStream.flush();            outputStream.close();        &#125; catch (WriterException | IOException e) &#123;            e.printStackTrace();        &#125;        //枚举内容替换成了字符串，不好展示        return &#123;&quot;code&quot;:2001,&quot;message&quot;:&quot;二维码生成成功&quot;&#125;;    &#125;</code></pre><h3 id="前端js代码"><a href="#前端js代码" class="headerlink" title="前端js代码"></a>前端js代码</h3><pre><code class="javascript"> $(document).ready(function () &#123;            $(&quot;#showQRCode&quot;).click(function () &#123;                let inputText = $(&quot;#inputText&quot;).val();                $.port(&#123;                    url: &quot;/qrCode&quot;,                    data: &#123;&quot;context&quot;:inputText&#125;,                    dataType: &quot;application/json&quot;,                    contentType: &quot;application/json&quot;,                    responseType: &quot;blob&quot;,                    accept:&quot;image/png&quot;,                    success: function (response)&#123;                        //后台的Base64编码作用于这里                        $(&quot;#qrCode&quot;).attr(&quot;src&quot;,&quot;data:image/png;base64,&quot;+response);                    &#125;,                    error: function () &#123;                        alert(&quot;请求错误&quot;);                    &#125;                &#125;)            &#125;);        &#125;);</code></pre><h3 id="前端HTML代码"><a href="#前端HTML代码" class="headerlink" title="前端HTML代码"></a>前端HTML代码</h3><pre><code class="html">&lt;div&gt;        &lt;img  id=&quot;qrCode&quot; style=&quot;padding-left: 20px&quot; alt=&quot;QRCode&quot; src=&quot;&quot;&gt;&lt;br/&gt;        &lt;label for=&quot;inputText&quot;&gt;输入二维码内容：&lt;/label&gt;&lt;input type=&quot;text&quot; id=&quot;inputText&quot;&gt;&lt;br/&gt;        &lt;button id=&quot;showQRCode&quot;&gt;提交&lt;/button&gt;&lt;/div&gt;</code></pre><hr><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>*使用<strong>Zxing</strong>第三方jar包，使用<strong>MultiFormatWriter</strong>的<strong>encode()<strong>方法生成一个二维码类</strong>BitMatrix</strong>的对象，然后用<strong>MatrixToImageWriter</strong>的流写入方法<strong>writeToStream()<strong>以</strong>png</strong>的形式写入<strong>OutputStresam</strong>流中，如果需要，可以进行相应的编码转换。*</p><p><em><strong>如果使用get的方式，直接往img标签的src属性添加生成二维码的访问地址即可，并且不需要base64编码。</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算文件的MD5</title>
      <link href="/2023/06/07/Java%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%96%87%E4%BB%B6%E7%9A%84MD5/"/>
      <url>/2023/06/07/Java%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%96%87%E4%BB%B6%E7%9A%84MD5/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-计算文件的MD5date-2022-04-20-09-41-15-031updated-2022-10-13-14-57-26-724url-x2F-archives-x2F-ji-suan-wen-jian-de-md5categories-Javatags-Java-MD5"><a href="#title-计算文件的MD5date-2022-04-20-09-41-15-031updated-2022-10-13-14-57-26-724url-x2F-archives-x2F-ji-suan-wen-jian-de-md5categories-Javatags-Java-MD5" class="headerlink" title="title: 计算文件的MD5date: 2022-04-20 09:41:15.031updated: 2022-10-13 14:57:26.724url: &#x2F;archives&#x2F;ji-suan-wen-jian-de-md5categories:- Javatags:- Java- MD5"></a>title: 计算文件的MD5<br>date: 2022-04-20 09:41:15.031<br>updated: 2022-10-13 14:57:26.724<br>url: &#x2F;archives&#x2F;ji-suan-wen-jian-de-md5<br>categories:<br>- Java<br>tags:<br>- Java<br>- MD5</h2><pre><code class="java">public String md5(File file)&#123;        try &#123;            MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);            FileInputStream fileInputStream = new FileInputStream(file);            ByteArrayOutputStream stream = new ByteArrayOutputStream();            byte [] bytes = new byte[1024];            int read = 0;            while ((read=(fileInputStream.read(bytes)))!=-1)&#123;                stream.write(bytes,0,read);            &#125;            fileInputStream.close();            stream.close();            byte[] byteArray = stream.toByteArray();            md5.update(byteArray);            byte[] digest = md5.digest();            BigInteger bigInteger = new BigInteger(1,digest);            //生成MD5的进制数            return bigInteger.toString(16);        &#125; catch (NoSuchAlgorithmException | IOException e) &#123;            throw new ApplicationException(CodeType.SERVICE_ERROR, &quot;MD5转换失败&quot;);        &#125;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Kafka安装</title>
      <link href="/2023/06/07/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka%E5%AE%89%E8%A3%85/"/>
      <url>/2023/06/07/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>首先下载Kafka的二进制包，以及Kafka-Manager Cmak工具</p><p><a href="https://downloads.apache.org/kafka/3.3.1/kafka_2.13-3.3.1.tgz">Kafka</a>(<a href="https://downloads.apache.org/kafka/3.3.1/kafka_2.13-3.3.1.tgz">https://downloads.apache.org/kafka/3.3.1/kafka_2.13-3.3.1.tgz</a>)</p><p><a href="https://github.com/yahoo/CMAK/releases/download/3.0.0.6/cmak-3.0.0.6.zip">Cmak</a>(<a href="https://github.com/yahoo/CMAK/releases/download/3.0.0.6/cmak-3.0.0.6.zip">https://github.com/yahoo/CMAK/releases/download/3.0.0.6/cmak-3.0.0.6.zip</a>)</p><p>解压Kafka到<code>/opt</code>目录shell</p><pre><code class="shell">tar -zxvf kafka_2.13-3.3.1.tgz -C /opt</code></pre><p>解压Cmak到<code>/opt</code>目录</p><pre><code class="shell">unzip cmak-3.0.0.6 -C /opt</code></pre><p>修改cmak的application.properties<code>/opt/cmak-3.0.0.6/conf/application.properties</code>的如下信息</p><pre><code class="shell"># The address the socket server listens on. If not configured, the host name will be equal to the value of# java.net.InetAddress.getCanonicalHostName(), with PLAINTEXT listener name, and port 9092.#   FORMAT:#     listeners = listener_name://host_name:port#   EXAMPLE:#     listeners = PLAINTEXT://your.host.name:9092#listeners=PLAINTEXT://:9092listeners=PLAINTEXT://10.254.0.2:9092# Listener name, hostname and port the broker will advertise to clients.# If not set, it uses the value for &quot;listeners&quot;.#advertised.listeners=PLAINTEXT://your.host.name:9092advertised.listeners=PLAINTEXT://10.254.0.2:9092# Settings prefixed with &#39;kafka-manager.&#39; will be deprecated, use &#39;cmak.&#39; instead.# https://github.com/yahoo/CMAK/issues/713kafka-manager.zkhosts=&quot;kafka-manager-zookeeper:2181&quot;#kafka-manager.zkhosts=$&#123;?ZK_HOSTS&#125;kafka-manager.zkhosts=&quot;10.254.0.2:2181&quot;cmak.zkhosts=&quot;kafka-manager-zookeeper:2181&quot;#cmak.zkhosts=$&#123;?ZK_HOSTS&#125;cmak.zkhosts=&quot;10.254.0.2:2181&quot;</code></pre><p>构建如下脚本，一键启动Kafka所需要的Zookeeper服务、Kafka服务以及Cmak管理工具</p><pre><code class="shell">#!/bin/bashoption=$1echo &quot;option $option&quot;case $option in   &#39;start&#39;)    # create kafka catalogue    if [ -d &#39;/root/kafka&#39; ]; then      echo &#39;kafka catalogue exists&#39;    else       mkdir /root/kafka      echo &#39;create kafka catalogue success&#39;    fi    # create kafka log catalogue    if [ -d &quot;/root/kafka/log&quot; ]; then      echo &#39;kafka log catalogue exists&#39;    else      mkdir /root/kafka/log      echo &#39;create kafka log catalogue success&#39;    fi    #  create kafka pid catalogue    if [ -d &#39;/root/kafka/pid&#39; ]; then      echo &#39;kafka pid catalogue exists&#39;    else      mkdir /root/kafka/pid      echo &#39;create kafka pid catalogue success&#39;    fi    # creare kafka zk log file     if [ -f &#39;/root/kafka/log/zk.log&#39; ]; then      echo &#39;kafka zk log file already exists&#39;    else       touch /root/kafka/log/zk.log      echo &#39;create kafka zk log file success&#39;    fi    # create zk pid file     if [ -f &#39;/root/kafka/pid/zk-pid&#39; ]; then      echo &#39;kafka zk pid file already exists&#39;    else      touch /root/kafka/pid/zk-pid      echo &#39;create kafka zk pid file success&#39;    fi    nohup  /opt/kafka_2.13-3.3.1/bin/zookeeper-server-start.sh /opt/kafka_2.13-3.3.1/config/zookeeper.properties &gt; /root/kafka/log/zk.log 2&gt;&amp;1 &amp;    echo $!    echo $! &gt; /root/kafka/pid/zk-pid    echo &#39;loading 1 minute ......&#39;     sleep 1m    # create kafka server log file    if [ -f &#39;/root/kafka/log/kafka.log&#39; ]; then      echo &#39;kafka server log file exists&#39;    else       touch /root/kafka/log/kafka.log      echo &#39;create kafka server log file success&#39;    fi    # create kafka pid pid file    if [ -f &#39;/root/kafka/pid/kafka-pid&#39; ]; then      echo &#39;kafka server pid file exists&#39;    else      touch /root/kafka/pid/kafka-pid      echo &#39;create kafka server pid file success&#39;    fi    export JMX_PORT=9999    nohup /opt/kafka_2.13-3.3.1/bin/kafka-server-start.sh /opt/kafka_2.13-3.3.1/config/server.properties &gt; /root/kafka/log/kafka.log 2&gt;&amp;1 &amp;    echo $!    echo $! &gt; /root/kafka/pid/kafka-pid    # create kafka-manager cmak log file      if [ -f &#39;/root/kafka/log/cmak.log&#39; ]; then        echo &#39;kafka manager cmak log file exists&#39;      else        touch /root/kafka/log/cmak.log        echo &#39;create kafka manager cmak log file success&#39;      fi    # create kafka-manager cmak pid file     if [ -f &#39;/root/kafka/pid/cmak-pid&#39; ]; then       echo &#39;kafka manager cmak pid file exists&#39;     else        touch /root/kafka/pid/cmak-pid       echo &#39;create kafka manager cmak pid file success&#39;     fi    nohup bash /opt/cmak-3.0.0.6/bin/cmak &gt; /root/kafka/log/cmak.log 2&gt;&amp;1 &amp;    echo $!    echo $! &gt; /root/kafka/pid/cmak-pid    echo &#39;loading 1 minute ......&#39;    sleep 1m    echo &#39;all server start success&#39;  ;;  &#39;stop&#39;)    zk_pid=$(cat /root/kafka/pid/zk-pid)    kill -9 $zk_pid    echo &#39;kill zookeeper server success&#39;    kafka_pid=$(cat /root/kafka/pid/kafka-pid)    kill -9 $kafka_pid    echo &#39;kill kafka server success&#39;    cmak_pid=$(cat /root/kafka/pid/cmak-pid)    kill -9 $cmak_pid    echo &#39;kill kafka manager cmak success&#39;         rm -rf /opt/cmak-3.0.0.6/RUNNING_PID  ;;  *)    echo &#39;option error&#39;  ;;esac</code></pre>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ与Systemd</title>
      <link href="/2023/06/07/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ%E4%B8%8ESystemd/"/>
      <url>/2023/06/07/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ%E4%B8%8ESystemd/</url>
      
        <content type="html"><![CDATA[<h1 id="RocketMQ与Systemd"><a href="#RocketMQ与Systemd" class="headerlink" title="RocketMQ与Systemd"></a>RocketMQ与Systemd</h1><p>RocketMQ的安装比较简单，只需要提供了JAVA_HOME环境，之后运行对于的脚本即可，所以这里主要介绍的RocketMQ与Systemd的配置，结合Shell脚本，一次性的启用namsesrv和borker以及web管理工具<code>rocketmq-dashboard</code></p><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>Java: openjdk-11</p><p>RocketMQ: <code>rocketmq-all-5.0.0-bin-release.zip</code><a href="https://www.apache.org/dyn/closer.cgi?path=rocketmq/5.0.0/rocketmq-all-5.0.0-bin-release.zip">下载</a></p><p>RocketMQ Dashboard: <code>rocketmq-dashboard-rocketmq-dashboard-1.0.0.tar.gz</code> <a href="https://github.com/apache/rocketmq-dashboard">源码地址,该项目需要自己编译成jar包</a></p><p>在下载了RocketMQ的二进制包之后，解压到指定位置，而后配置对于的<code>namesrv</code>和<code>borker</code>服务，systemd的服务配置在<code>/usr/lib/systemd/system/</code>或者<code>/etc/systemd/system/</code>目录下</p><p>rmq_namesrv.service</p><pre><code class="shell">[Unit]Description=rocketmq namesrvAfter=network.target[Service]Type=simpleExecStart=/opt/rocketmq-all-5.0.0-bin-release/bin/mqnamesrvExecReload=/bin/kill -s HUP $MAINPIDExecStop=//opt/rocketmq-all-5.0.0-bin-release/bin/mqshutdown namesrv[Install]WantedBy=mulitiple-rmq-namesrv.target</code></pre><p>rmq_borker.service</p><pre><code class="shell">[Unit]Description=rocketmq brokerAfter=network.target[Service]Type=simpleExecStart=/opt/rocketmq-all-5.0.0-bin-release/bin/mqbroker -n localhost:9876 --enable-proxyExecReload=/bin/kill -s HUP $MAINPIDExecStop=/opt/rocketmq-all-5.0.0-bin-release/bin/mqshutdown broker[Install]WantedBy=multiple-rmq-broker.target</code></pre><p>在配置了这两个服务之后，即可通过systemctl start&#x2F;stop&#x2F;restart来执行服务了，由于每次都需要启动<code>namesrv</code>和<code>borker</code>服务还有web管理工具过于麻烦，所以引入<code>shell</code>脚本进行处理</p><p>rocketmq.shell</p><pre><code class="shell">#!/bin/bashinstruct=$1echo $instructcase $instruct in &#39;start&#39;)   systemctl start rmq_namesrv   systemctl start rmq_borker   export NAMSESRV_ADDR=localhost:9876   nohup java -jar /opt/rocketmq-dashboard-rocketmq-dashboard-1.0.0/target/rocketmq-dashboard-1.0.0.jar &gt; /root/rocketmq-dashboard.log &amp;   echo $! &gt; /root/rmq-d-pid   echo &quot;RocketMQ Start SUCCESS PID: &quot; + $! ;; &#39;stop&#39;)   systemctl stop rmq_namesrv   systemctl stop rmq_borker   PID=$(cat /root/rmq-d-pid)   kill -9 $&#123;PID&#125;   echo &quot;RocketMQ Stop SUCCESS&quot; ;; *)   echo &quot;Input instruct error&quot; ;;esac</code></pre><p>可以通过执行该shell脚本对RocketMQ进行启动和关闭</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ关系梳理</title>
      <link href="/2023/06/07/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ%E5%85%B3%E7%B3%BB%E6%A2%B3%E7%90%86/"/>
      <url>/2023/06/07/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ%E5%85%B3%E7%B3%BB%E6%A2%B3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="RocketMQ关系梳理"><a href="#RocketMQ关系梳理" class="headerlink" title="RocketMQ关系梳理"></a>RocketMQ关系梳理</h1><p>对于RocketMQ的生产者、消息、消费者、消费者分组、主题、队列、订阅关系的梳理</p><p>主题: 主题是订阅的首要关系，不管是生产者还是消费者都是和主题进行关联订阅，而主题内是由队列组成，队列拥有读、写等权限控制，主题通过队列进行横向扩展，来提要主题的性能，主题是存储消息的实际。</p><p>消息: 消息是队列内信息流通的最小粒子，消息本身拥有一定的特性，如延迟消息等。</p><p>生产者: 生产者通过向指定的主题发送消息完成生产任务，更多理解暂时没有</p><p>消费者: 消费者必定需要提起续费这分组，因为消费者与主题之间的订阅关系是由消费者分组完成的，换句话说，消费者与主题没有直接关系，与主题有直接关系的是消费者组，消费者组通过订阅关系与主题构建关联，而消费者属于消费者组，那么在消费者组得到消息之后，通过进一步的消息订阅关系分发给组下面的消费者，需要注意的是，在同一个消费者分组下的消费者，其订阅关系必须保持一致性，如果多个消费者分组订阅同一个主题，那么这个主题的消息会分发给所有的消费者分组。</p><p><img src="https://rocketmq.apache.org/zh/assets/images/archiforproducer-ebb8ff832f6e857cbebc2c17c2044a3b.png" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper单机部署</title>
      <link href="/2023/06/07/%E4%B8%AD%E9%97%B4%E4%BB%B6/Zookeeper%E5%8D%95%E6%9C%BA%E9%83%A8%E7%BD%B2/"/>
      <url>/2023/06/07/%E4%B8%AD%E9%97%B4%E4%BB%B6/Zookeeper%E5%8D%95%E6%9C%BA%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-Zookeeper单机部署date-2022-10-10-13-59-49-654updated-2022-10-13-14-44-16-087url-x2F-archives-x2F-zookeeper-dan-ji-bu-shucategories-Zookeepertags-Zookeeper"><a href="#title-Zookeeper单机部署date-2022-10-10-13-59-49-654updated-2022-10-13-14-44-16-087url-x2F-archives-x2F-zookeeper-dan-ji-bu-shucategories-Zookeepertags-Zookeeper" class="headerlink" title="title: Zookeeper单机部署date: 2022-10-10 13:59:49.654updated: 2022-10-13 14:44:16.087url: &#x2F;archives&#x2F;zookeeper-dan-ji-bu-shucategories:- Zookeepertags:- Zookeeper"></a>title: Zookeeper单机部署<br>date: 2022-10-10 13:59:49.654<br>updated: 2022-10-13 14:44:16.087<br>url: &#x2F;archives&#x2F;zookeeper-dan-ji-bu-shu<br>categories:<br>- Zookeeper<br>tags:<br>- Zookeeper</h2><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><blockquote><p>CentOS7、openJdk11</p></blockquote><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>首先使用<code>wget</code>下载zk的二进制包<pre><code class="shell">wget https://dlcdn.apache.org/zookeeper/zookeeper-3.8.0/apache-zookeeper-3.8.0-bin.tar.gz</code></pre></li><li>解压出到opt目录下<pre><code class="shell">tar -zxvf apache-zookeeper-3.8.0-bin.tar.gz -O /opt</code></pre></li><li>配置systemd服务管理<br> 在&#x2F;etc&#x2F;systemd&#x2F;system目录下创建zkServer.service文件<pre><code class="shell">[Unit]Description=zkServer[Service]Type=forking#PIDFile=/var/run/zkServer_2181.pidExecStart=/opt/apache-zookeeper-3.8.0-bin/bin/zkServer.sh startExecStartPost=/bin/sleep 0.1ExecReload=/bin/kill -s HUP $MAINPIDExecStop=/opt/apache-zookeeper-3.8.0-bin/bin/zkServer.sh stopPrivateTmp=true[Install]WantedBy=multi-user.target</code></pre><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html">含义参考</a></li><li>使用systemd启用服务即可<pre><code class="shell"># 启用systemctl start zkServer# 停止systemctl stop zkServer# 重启systemctl restart zkServer</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android_头部导航标签</title>
      <link href="/2023/06/07/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/Android_%E5%A4%B4%E9%83%A8%E5%AF%BC%E8%88%AA%E6%A0%87%E7%AD%BE/"/>
      <url>/2023/06/07/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/Android_%E5%A4%B4%E9%83%A8%E5%AF%BC%E8%88%AA%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="Toolbar"><a href="#Toolbar" class="headerlink" title="Toolbar"></a>Toolbar</h1><p>关于toolbar使用的几个要点，包如下</p><pre><code class="xml">androidx.appcompat.widget.Toolbar</code></pre><p>这里作为toolbar的最左标签使用</p><pre><code class="xml">app:navigationIcon=&quot;@mipmap/sidebar&quot;</code></pre><p>最左侧按钮点击事件，这里的点击事件有一个很重要的事情，就是只有在toolbar提交之后才能生效，也就是</p><pre><code class="java">setSupportActionBar(toolbar);</code></pre><pre><code class="java">@Override    public boolean onOptionsItemSelected(@NonNull MenuItem item) &#123;        if (item.getItemId() ==android.R.id.home)&#123;            drawerLayout.openDrawer(Gravity.LEFT);        &#125;        return super.onOptionsItemSelected(item);    &#125;</code></pre><p>而其他的所有操作，如设置title，logo等等方法，也要在提交了toolbar之后才能生效，例如</p><pre><code class="java"># 设置title无效getSupportActionBar().setDisplayShowTitleEnabled(false);</code></pre><p>还有设置toolbar的title的颜色字体大小，等等信息</p>]]></content>
      
      
      <categories>
          
          <category> 前端杂烩 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android网络请求回调</title>
      <link href="/2023/06/07/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/Android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%9B%9E%E8%B0%83/"/>
      <url>/2023/06/07/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/Android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%9B%9E%E8%B0%83/</url>
      
        <content type="html"><![CDATA[<h1 id="Android的HTTP网络请求超时UI更新（回调）"><a href="#Android的HTTP网络请求超时UI更新（回调）" class="headerlink" title="Android的HTTP网络请求超时UI更新（回调）"></a>Android的HTTP网络请求超时UI更新（回调）</h1><h3 id="原因及运行原理"><a href="#原因及运行原理" class="headerlink" title="原因及运行原理"></a>原因及运行原理</h3><p>当在网络请求出现连接超时（httpURLConnection.setConnectTimeout(TimeOut)）的时候，此时调用的活动中的Dialog弹窗会一直浮现在桌面上，而网络请求是位于子线程，活动只是调用之后就没有太多的关联，这时当网络出现连接超时的时候会一直卡在httpURLConnection.connect()中，此时可以在网络请求类中新建一个接口，并且实现一个刷新方法，再在活动中实例化一个请求类，并且参数为接口对象，然后再到网络请求出现超时，并且抛出异常的try…catch代码块的异常处理块中用接口对象调用刷新的方法，由于接口内的刷新方法时抽象方法，所以会自动往子级里面去找到运行的代码块，也就是说运行活动中覆写的代码块，注意：虽然运行的代码块时活动中的，但是其调用的主体方法还是在子线程中，所以需要更新UI的时候，还是需要回调到主线程中        </p><pre><code class="java">public  class BaseHttpConn &#123;    private static final String TAG = &quot;BaseHttpConn&quot;;    private static TimeOut shuaxin;    private static int TimeOut = 3*1000;    public static HttpURLConnection httpConn(String baseUrl, HashMap&lt;String, String&gt; map) &#123;        HttpURLConnection httpURLConnection = null;        try &#123;            URL url = new URL(baseUrl);            httpURLConnection = (HttpURLConnection) url.openConnection();            httpURLConnection.setConnectTimeout(TimeOut);//连接超时            httpURLConnection.setReadTimeout(TimeOut);//读取超时            httpURLConnection.setRequestMethod(&quot;POST&quot;);//请求方式            httpURLConnection.setInstanceFollowRedirects(true);//是否重定向            httpURLConnection.setUseCaches(true);//是否启用缓存            httpURLConnection.setRequestProperty(&quot;Content-Type&quot;,&quot;application/json&quot;);//传入服务器的数据类型            OutputStream outputStream = httpURLConnection.getOutputStream();            outputStream.write(getByte(map));            outputStream.close();        &#125; catch (Exception e) &#123;            e.printStackTrace();            httpURLConnection.disconnect();//关闭此次网络请求            shuaxin.ShuaXin();//通过接口对象调用抽象方法ShuaXin();        &#125;        return httpURLConnection;    &#125;    private static byte[] getByte(HashMap&lt;String,String&gt; map) &#123;        JSONObject jsonObject = new JSONObject();        for(String key: map.keySet())&#123;            try &#123;                jsonObject.put(key,map.get(key));            &#125; catch (JSONException e) &#123;                e.printStackTrace();            &#125;        &#125;        return jsonObject.toString().getBytes();    &#125;    public BaseHttpConn(TimeOut timeOut) &#123;        this.shuaxin = timeOut;    &#125;    //监听接口    public interface TimeOut&#123;        void ShuaXin();//接口中刷新的方法    &#125;&#125;</code></pre><h3 id="Activity中的代码"><a href="#Activity中的代码" class="headerlink" title="Activity中的代码"></a>Activity中的代码</h3><pre><code class="java">     BaseHttpConn baseHttpConn = new BaseHttpConn(new BaseHttpConn.TimeOut() &#123;        @Override        public void ShuaXin() &#123;            progressDialog.dismiss();            getActivity().runOnUiThread(new Runnable() &#123;//位于碎片中，所以需要通过getActivity()获取活动                @Override                public void run() &#123;                    Toast.makeText(getContext(),&quot;网络连接失败&quot;,Toast.LENGTH_SHORT).show();                &#125;            &#125;);        &#125;    &#125;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端杂烩 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS布局问题</title>
      <link href="/2023/06/07/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/CSS%E5%B8%83%E5%B1%80%E9%97%AE%E9%A2%98/"/>
      <url>/2023/06/07/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/CSS%E5%B8%83%E5%B1%80%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS布局问题"><a href="#CSS布局问题" class="headerlink" title="CSS布局问题"></a>CSS布局问题</h1><pre><code class="css"># 作为行内表格元素，可以使相对于父元素有效display: inline-table;width:100%;height: 100%;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端杂烩 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML5图片拖放</title>
      <link href="/2023/06/07/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/HTML5%E5%9B%BE%E7%89%87%E6%8B%96%E6%94%BE/"/>
      <url>/2023/06/07/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/HTML5%E5%9B%BE%E7%89%87%E6%8B%96%E6%94%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="实现HTML5中图片的拖放"><a href="#实现HTML5中图片的拖放" class="headerlink" title="实现HTML5中图片的拖放"></a>实现HTML5中图片的拖放</h2><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;阿杰之家&lt;/title&gt;        &lt;style type=&quot;text/css&quot;&gt;            #div1,            #div2 &#123;                float: left;                width: 500px;                height: 350px;                margin: 10px;                padding: 10px;                border: 1px solid #aaaaaa;            &#125;        &lt;/style&gt;        &lt;script&gt;            function allowDrop(ev) &#123;                // 6、默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式,这要通过调用 ondragover 事件的 event.preventDefault() 方法.                ev.preventDefault();            &#125;            function drag(ev) &#123;                // 3、dataTransfer.setData() 方法设置被拖数据的数据类型和值                // 4、Text 是一个 DOMString 表示要添加到 drag object 的拖动数据的类型。值是可拖动元素的 id (&quot;drag1&quot;)。                ev.dataTransfer.setData(&quot;Text&quot;, ev.target.id);            &#125;            function drop(ev) &#123;                // 8、调用 preventDefault() 来避免浏览器对数据的默认处理（drop 事件的默认行为是以链接形式打开）                ev.preventDefault();                // 9、通过 dataTransfer.getData(&quot;Text&quot;) 方法获得被拖的数据。该方法将返回在 setData() 方法中设置为相同类型的任何数据。被拖数据是被拖元素的 id (&quot;drag1&quot;)                var data = ev.dataTransfer.getData(&quot;Text&quot;);                // 10、把被拖元素追加到放置元素（目标元素）中                ev.target.appendChild(document.getElementById(data));            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!-- 5、ondragover 事件规定在何处放置被拖动的数据。 --&gt;        &lt;!-- 7、当放置被拖数据时，会发生 drop 事件 --&gt;        &lt;div id=&quot;div1&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt;            &lt;!-- 1、为了使元素可拖动，把 draggable 属性设置为 true --&gt;            &lt;!-- 2、ondragstart 属性调用了一个函数，drag(event)，它规定了被拖动的数据。 --&gt;            &lt;img src=&quot;./img/logo.png&quot; draggable=&quot;true&quot; ondragstart=&quot;drag(event)&quot; id=&quot;drag1&quot; width=&quot;500&quot; height=&quot;350&quot;&gt;&lt;/div&gt;        &lt;div id=&quot;div2&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt;&lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端杂烩 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML高度塌陷</title>
      <link href="/2023/06/07/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/HTML%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7/"/>
      <url>/2023/06/07/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/HTML%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML盒子高度塌陷"><a href="#HTML盒子高度塌陷" class="headerlink" title="HTML盒子高度塌陷"></a>HTML盒子高度塌陷</h1><p>使用<code>overflow: hidden;</code>可以处理盒子的高度塌陷</p><p>引用：<a href="https://www.cnblogs.com/luoqian/p/5987788.html">https://www.cnblogs.com/luoqian/p/5987788.html</a></p><p>最近在看《CSS Mastery》这本书，里面有用overflow：hidden来清理浮动的方法。但是一直想不明白为什么能够实现清除浮动，查阅了网络上的解释，下面来总结一下。</p><p>一、首先来想想</p><p>我们大家理解的overflow:hidden是超出该元素的部分进行隐藏。这个时候就需要明确一点，该元素的高度是怎么定义的。当一个div中的两个元素浮动之后，此时div的高度就会塌陷，此时div的高度为0。那是不是意味着就要将浮动元素隐藏起来，如果是真的隐藏就是反布局常识的。所以这中间肯定有我们现在还不知道的机制。</p><p>二、不了解的机制-BFC</p><p>定义：BFC（Block Formatting Context）全称是块级格式化上下文，用于对块级元素排版，默认情况下只有根元素（body）一个块级上下文，但是如果一个块级元素设置了float:left,overflow:hidden或position:absolute样式，就会为这个块级元素生产一个独立的块级上下文，使这个块级元素内部的排版完全独立。</p><p>作用：独立的块级上下文可以包裹浮动流，全部浮动子元素也不会引起容器高度塌陷，就是说包含块会把浮动元素的高度也计算在内，所以就不用清除浮动来撑起包含块的高度。</p><p>三、总结清除浮动的方法</p><p>我经常用到的清除浮动的方法有</p><p>1、添加额外标签设置clearfix类为clear:both;</p><p>　　原理是这个空的div能让父级获取到高度，是因为设置之后这个div的左右都不能有浮动元素，所以这个空的div元素会向下移动，直到换行，而为了让这个div能够换行，父元素至少要包含浮动元素的高度才能提高足够的空间，这样实现清除浮动的影响。</p><p>2、设置父元素为浮动元素</p><p>3、设置position:absolute</p><p>我不常用的清除浮动的方法有</p><p>1、父级div定义height</p><p>3、overflow:hidden</p><p>2、父级div定义伪类:after和zoom;</p><p>　　这个方法的原理还不理解，欢迎大神解答。</p><p>四、清除浮动的影响方法分类</p><p>参考张鑫旭老师的说法，清除浮动的说法是不准确的。应该是为清除浮动的影响。我也觉得张老师的说法是正确的，因为float:none才叫清除浮动。张老师还说到了包裹的这个概念，根据这个概念将清除浮动的影响的方法分为两大类。</p><p>一类是clear:both&#x2F;left&#x2F;right，这就不用说了。</p><p>另一类是：包裹清除，因为他发现浮动、绝对定位、inline-block、overflow都有自适应元素宽度的特性，就想到了用包裹来形容。</p>]]></content>
      
      
      <categories>
          
          <category> 前端杂烩 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript下载文件</title>
      <link href="/2023/06/07/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/JavaScript%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/"/>
      <url>/2023/06/07/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/JavaScript%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>JavaScript异步请求，把响应的Base64图片内容下载到本地文件存储</p><pre><code class="javascript">/** * Base64的文件下载 * @param content Base64字符内容 * @param fileName 文件名称 */function downloadFile(content, fileName) &#123; //下载base64图片    let base64ToBlob = function (code) &#123;        let parts = code.split(&#39;;base64,&#39;);        let contentType = parts[0].split(&#39;:&#39;)[1];        let raw = window.atob(parts[1]);        let rawLength = raw.length;        let uInt8Array = new Uint8Array(rawLength);        for (let i = 0; i &lt; rawLength; ++i) &#123;            uInt8Array[i] = raw.charCodeAt(i);        &#125;        return new Blob([uInt8Array], &#123;            type: contentType        &#125;);    &#125;;    let aLink = document.createElement(&#39;a&#39;);    let blob = base64ToBlob(content); //new Blob([content]);    let evt = document.createEvent(&quot;HTMLEvents&quot;);    evt.initEvent(&quot;click&quot;, true, true); //initEvent 不加后两个参数在FF下会报错  事件类型，是否冒泡，是否阻止浏览器的默认行为    aLink.download = fileName;    aLink.href = URL.createObjectURL(blob);    aLink.click();&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端杂烩 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript获取视频流且回显</title>
      <link href="/2023/06/07/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/JavaScript%E8%8E%B7%E5%8F%96%E8%A7%86%E9%A2%91%E6%B5%81%E4%B8%94%E5%9B%9E%E6%98%BE/"/>
      <url>/2023/06/07/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/JavaScript%E8%8E%B7%E5%8F%96%E8%A7%86%E9%A2%91%E6%B5%81%E4%B8%94%E5%9B%9E%E6%98%BE/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-JavaScript获取视频流且回显date-2022-04-20-09-38-55-438updated-2022-10-13-14-58-40-564url-x2F-archives-x2F-javascript-huo-qu-shi-pin-liu-qie-hui-xiancategories-JavaScripttags-JavaScript"><a href="#title-JavaScript获取视频流且回显date-2022-04-20-09-38-55-438updated-2022-10-13-14-58-40-564url-x2F-archives-x2F-javascript-huo-qu-shi-pin-liu-qie-hui-xiancategories-JavaScripttags-JavaScript" class="headerlink" title="title: JavaScript获取视频流且回显date: 2022-04-20 09:38:55.438updated: 2022-10-13 14:58:40.564url: &#x2F;archives&#x2F;javascript-huo-qu-shi-pin-liu-qie-hui-xiancategories:- JavaScripttags:- JavaScript"></a>title: JavaScript获取视频流且回显<br>date: 2022-04-20 09:38:55.438<br>updated: 2022-10-13 14:58:40.564<br>url: &#x2F;archives&#x2F;javascript-huo-qu-shi-pin-liu-qie-hui-xian<br>categories:<br>- JavaScript<br>tags:<br>- JavaScript</h2><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;style&gt;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;video id=&quot;video&quot; width=&quot;640&quot; height=&quot;480&quot; autoplay=&quot;autoplay&quot;&gt;&lt;/video&gt;        &lt;br/&gt;        &lt;button id=&quot;snap&quot;&gt;截取图像&lt;/button&gt;&lt;button id=&quot;start&quot;&gt;开始录制&lt;/button&gt;&lt;button id=&quot;stop&quot;&gt;停止录制&lt;/button&gt;        &lt;br/&gt;        &lt;canvas id=&quot;canvas&quot; width=&quot;640&quot; height=&quot;480&quot;&gt;&lt;/canvas&gt;    &lt;/body&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        let videoView = document.getElementById(&quot;video&quot;);        let buttonView = document.getElementById(&quot;snap&quot;);        let startButton = document.getElementById(&quot;start&quot;);        let stopButton = document.getElementById(&quot;stop&quot;);        let canvasView = document.getElementById(&quot;canvas&quot;);        navigator.mediaDevices.getDisplayMedia(&#123;            video: &#123;                width: 640,                height: 480            &#125;,            audio: true        &#125;).then(stream =&gt; &#123;            console.log(&quot;摄像头打开成功！！！&quot;, stream);            //以ID为基准,video控件的ID是什么此处的video就是什么            video.srcObject = stream;            // 创建下载对象            let mediaRecorder = new MediaRecorder(stream, &#123;                audioBitsPerSecond: 128000, // 音频码率                videoBitsPerSecond: 100000, // 视频码率                mimeType: &#39;video/webm;codecs=h264&#39; // 编码格式            &#125;);            startButton.onclick = (e =&gt; &#123;                console.log(&quot;触发下载按钮！！！&quot;, e)                mediaRecorder.start(5000);            &#125;);            stopButton.onclick = (e =&gt; &#123;                console.log(&quot;触发结束按钮！！！&quot;, e)                mediaRecorder.stop();            &#125;);            mediaRecorder.ondataavailable = (e =&gt; &#123;                console.log(&quot;开始下载&quot;)                // 下载视频                var blob = new Blob([e.data], &#123; &#39;type&#39; : &#39;video/mp4&#39; &#125;)                let a = document.createElement(&#39;a&#39;)                a.href = URL.createObjectURL(blob)                a.download = `test.mp4`                a.click()            &#125;);            //监听流录入失败            video.onerror = (err =&gt; &#123;                console.log(&quot;加载错误！！！&quot;, err);            &#125;);            //监听流录入成功            video.onloadeddata = (e =&gt; &#123;                console.log(&quot;加载成功！！！&quot;, e);            &#125;);        &#125;).catch(stream =&gt; &#123;            console.log(&quot;摄像头打开失败！！！&quot;, stream);        &#125;);        //给button按钮设置一个点击事件监听        buttonView.onclick = function() &#123;            //获取画布的2d上下文，然后把视频内的一帧绘制到画布上            canvasView.getContext(&quot;2d&quot;).drawImage(videoView, 0, 0, 640, 480)        &#125;    &lt;/script&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端杂烩 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Javascript正则</title>
      <link href="/2023/06/07/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/Javascript%E6%AD%A3%E5%88%99/"/>
      <url>/2023/06/07/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/Javascript%E6%AD%A3%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="Javascript正则"><a href="#Javascript正则" class="headerlink" title="Javascript正则"></a>Javascript正则</h2><pre><code class="javascript">let newData  = data.replace(/\&quot;toId\&quot;:(\d+)/,&#39;&quot;toId&quot;: &quot;$1&quot;&#39;);data = JSON.parse(newData)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端杂烩 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Javascript的dom操作</title>
      <link href="/2023/06/07/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/Javascript%E7%9A%84dom%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/06/07/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/Javascript%E7%9A%84dom%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="JS原生DOM操作"><a href="#JS原生DOM操作" class="headerlink" title="JS原生DOM操作"></a>JS原生DOM操作</h1><pre><code class="javascript">let mainView = document.getElementById(&quot;main&quot;);                console.log(mainView)                let textDom = document.createElement(&quot;img&quot;);                let x = Math.random()*200+&quot;px&quot;;                let y = (Math.random()*300+100)+&quot;px&quot;;                textDom.style.top = y;                textDom.style.width = &quot;20px&quot;;                textDom.style.height = &quot;20px&quot;;                textDom.style.left = x;                textDom.style.border = &quot;solid 1px #cccccc&quot;;                textDom.style.zIndex = &quot;999&quot;;                textDom.style.position = &quot;absolute&quot;;                textDom.setAttribute(&quot;src&quot;,&quot;../../static/log.jpg&quot;);                // textDom.setAttribute(&quot;src&quot;,&quot;http://a2.att.hudong.com/36/48/19300001357258133412489354717.jpg&quot;);                mainView.appendChild(textDom)                console.log(mainView)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端杂烩 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS配置创建VUE项目</title>
      <link href="/2023/06/07/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/NodeJS%E9%85%8D%E7%BD%AE%E5%88%9B%E5%BB%BAVUE%E9%A1%B9%E7%9B%AE/"/>
      <url>/2023/06/07/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/NodeJS%E9%85%8D%E7%BD%AE%E5%88%9B%E5%BB%BAVUE%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h1><p>查看node版本</p><pre><code class="shell">node -v</code></pre><p>查看npm版本</p><pre><code class="shell">npm -v</code></pre><p>查看配置文件</p><pre><code class="shell">npm config list</code></pre><p>修改本地仓库</p><pre><code class="shell">npm config set prefix &quot;C:\Software\node\node_global&quot;npm config set cache &quot;C:\Software\node\node_cache&quot;</code></pre><p>修改镜像站</p><pre><code class="shell">npm config set registry=https://registry.npm.taobao.org</code></pre><p>node更新</p><pre><code class="shell">*# 全局安装n$ npm install -g n # 升级到最新稳定版$ n stable# 升级到最新版$ n latest# 升级到定制版$ n v7.10.0# 切换使用版本$ n 7.10.0 (ENTER)</code></pre><p>配置文件所在位置<code>C:\Users\Administrator\.npmrc</code></p><p>获取镜像信息（非安装）</p><pre><code class="shell">npm info vue</code></pre><p>更新模块命令</p><pre><code class="shell">#老版本安装方式 2.*npm install npm –g</code></pre><pre><code class="shell">#老版本安装方式 3.* /4.*npm install -g @vue/cli</code></pre><ul><li>npm install&#96;：表示更新</li><li><code>第二个npm</code>：表示需要更新的模块</li><li><code>-g</code>：表示安装到global目录下</li></ul><p>配置NodeJS的环境变量</p><pre><code class="shell">path: D:\software\nodejs</code></pre><p>配置global仓的环境变量</p><pre><code class="shell">path: D:\software\nodejs\node_global</code></pre><p>新增一个<code>NODE_PATH</code>环节变量（子项的全局命令）</p><pre><code class="shell">D:\software\nodejs\node_global\node_modules</code></pre><p>安装vue，安装vue-routher，安装vue脚手架，验证是否安装成功</p><pre><code class="shell">npm install vue -gnpm install vue-routher -gnpm install @vue/cli -gvue -V</code></pre><hr><p><strong>老版本构建方式</strong></p><p>1、构建初始化vue项目</p><pre><code class="shell">vuew init webpack vue01</code></pre><p>2、进入vue01的目录，初始化安装依赖</p><pre><code class="shell">npm install</code></pre><p>3、运行vue01的dev状态</p><pre><code class="shell">npm run dev</code></pre><p>然后访问**<a href="http://localhost:8080/">http://localhost:8080</a>**</p><p>4、编译生成静态文件</p><pre><code class="shell">npm run build</code></pre><hr><p><strong>新版本构建方式</strong></p><pre><code class="shell">vue create vue01</code></pre><p>可以选择创建的方式，moban是我创建的模板，可以选择default默认，或者Manually重新选择</p><blockquote><p>√ Babel<br>× TyreScript<br>× Progressive Web App (PWA) Support<br>√ Routher<br>√ Vuex<br>√ CSS Pre-processors<br>× Linter &#x2F; Formatter<br>× Unit Testing<br>× E2E Testing</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端杂烩 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令</title>
      <link href="/2023/06/07/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/06/07/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Git基本常用命令"><a href="#Git基本常用命令" class="headerlink" title="Git基本常用命令"></a>Git基本常用命令</h1><pre><code class="shell">#初始化一个Git仓库git init#把文件添加到本地git仓储缓存git add &quot;file name&quot;#把当前目录下全部文件加入到本地git仓储缓存git add .#把仓储缓存提交上去git commit -m&quot;description&quot;#查看所有的远程分支git remote -v#添加远程分支git remote add origin &quot;git remote warehouse url&quot;#移除本地添加的远程分支git remote remove &quot;remote branch name&quot;#获取远程分支与本地分支合并git pull#把本地分支提交到远程分支git push#查看所有的远程分支和本地分支git branch -a#查看所有的本地分支git branch#本地分支与远程分支关联git branch --set-upstream-to=origin/master master#创建本地分支git branch &quot;local branch name&quot;#清除输入过的账号密码git config --system --unset credential.helper#回滚git loggit checkout [commit id] [file name]commit id:commit提交的编号file name:需要回滚的文件名称，不输入则整个版本回滚#克隆远程仓库到本地#fileName:为指定本地文件夹的名字，如果没有就会使用远程仓库默认s的名称git clone &quot;git remote warehouse url&quot; [ specified file name]</code></pre><h2 id="谨慎使用"><a href="#谨慎使用" class="headerlink" title="谨慎使用"></a>谨慎使用</h2><pre><code class="shell">#&#39;fatal: refusing to merge unrelated histories&#39;:无法合并两个不相干分支，此命令可强行合并建立关系git pull origin master --allow-unrelated-histories</code></pre><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p><code>.gitignore</code>：文件的内容将是忽略提交的部分，也就是git不会检索该文件指定的文件和文件夹</p><p>例如：</p><pre><code class="shell">HELP.mdtarget/!.mvn/wrapper/maven-wrapper.jar!**/src/main/**!**/src/test/**### STS ###.apt_generated.classpath.factorypath.project.settings.springBeans.sts4-cache### IntelliJ IDEA ###.idea*.iws*.iml*.ipr### NetBeans ###/nbproject/private//nbbuild//dist//nbdist//.nb-gradle/build/### VS Code ###.vscode/</code></pre><p>更多高级操作见下一篇：Git操作</p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git设置网络代理</title>
      <link href="/2023/06/07/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86/"/>
      <url>/2023/06/07/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="设置http、https代理"><a href="#设置http、https代理" class="headerlink" title="设置http、https代理"></a>设置http、https代理</h2><pre><code class="properties">git config --global http.proxy http://127.0.0.1:10809git config --global https.proxy socks5://127.0.0.1:10808</code></pre><h2 id="查看http、https代理配置情况"><a href="#查看http、https代理配置情况" class="headerlink" title="查看http、https代理配置情况"></a>查看http、https代理配置情况</h2><pre><code class="properties">git config --global --get http.proxygit config --global --get https.proxy</code></pre><h2 id="取消http、https代理配置"><a href="#取消http、https代理配置" class="headerlink" title="取消http、https代理配置"></a>取消http、https代理配置</h2><pre><code class="properties">git config --global --unset http.proxygit config --global --unset https.proxy</code></pre>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IntelliJ_IDEA_快捷键</title>
      <link href="/2023/06/07/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IntelliJ_IDEA_%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2023/06/07/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IntelliJ_IDEA_%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="IntelliJ-IDEA-快捷键"><a href="#IntelliJ-IDEA-快捷键" class="headerlink" title="IntelliJ IDEA 快捷键"></a>IntelliJ IDEA 快捷键</h1><h3 id="1-Editing-编辑"><a href="#1-Editing-编辑" class="headerlink" title="1. Editing(编辑)"></a><strong>1. Editing(编辑)</strong></h3><table><thead><tr><th align="left"><strong>快捷键</strong></th><th align="left"><strong>介绍</strong></th></tr></thead><tbody><tr><td align="left"><strong>Ctrl +Space</strong></td><td align="left"><strong>基本代码补全，输入字母按后列出匹配的词组</strong></td></tr><tr><td align="left"><strong>Ctrl+Shift+Space</strong></td><td align="left"><strong>智能代码补全，列出与预期类型一致的方法或变量</strong></td></tr><tr><td align="left"><strong>Ctrl+Alt+Space</strong></td><td align="left"><strong>补全类名</strong></td></tr><tr><td align="left"><strong>Ctrl+Shift+Enter</strong></td><td align="left"><strong>补全语句</strong></td></tr><tr><td align="left"><strong>Ctrl+P</strong></td><td align="left"><strong>显示方法参数</strong></td></tr><tr><td align="left"><strong>Ctrl+Q</strong></td><td align="left"><strong>显示注释文档</strong></td></tr><tr><td align="left"><strong>Shift+F1</strong></td><td align="left"><strong>显示外部文档</strong></td></tr><tr><td align="left"><strong>Ctrl+mouse over code</strong></td><td align="left"><strong>显示描述信息</strong></td></tr><tr><td align="left"><strong>Ctrl+F1</strong></td><td align="left"><strong>显示提示、警告、错误等信息</strong></td></tr><tr><td align="left"><strong>Alt+Insert</strong></td><td align="left"><strong>生成代码，生成 Getter、Setter、构造器等</strong></td></tr><tr><td align="left"><strong>Ctrl+O</strong></td><td align="left"><strong>重写父类方法</strong></td></tr><tr><td align="left"><strong>Ctrl+I</strong></td><td align="left"><strong>实现接口方法</strong></td></tr><tr><td align="left"><strong>Ctrl+Alt+T</strong></td><td align="left"><strong>使用(if..else, try..catch, for, synchronized 等)包围选中语句</strong></td></tr><tr><td align="left"><strong>Ctrl+&#x2F;</strong></td><td align="left"><strong>使用“&#x2F;&#x2F;”注释或取消注释</strong></td></tr><tr><td align="left"><strong>Ctrl+Shift+&#x2F;</strong></td><td align="left"><strong>使用“&#x2F;** **&#x2F;”注释或取消注释</strong></td></tr><tr><td align="left"><strong>Ctrl+W</strong></td><td align="left"><strong>选择代码块，连续按会增加选择外层的代码块</strong></td></tr><tr><td align="left"><strong>Ctrl+Shift+W</strong></td><td align="left"><strong>与“Ctrl+W”相反，减少选择代码块</strong></td></tr><tr><td align="left"><strong>Alt+Q</strong></td><td align="left"><strong>显示类描述信息</strong></td></tr><tr><td align="left"><strong>Alt+Enter</strong></td><td align="left"><strong>显示快速修复列表</strong></td></tr><tr><td align="left"><strong>Ctrl+Alt+L</strong></td><td align="left"><strong>格式化代码</strong></td></tr><tr><td align="left"><strong>Ctrl+Alt+O</strong></td><td align="left"><strong>优化 Imports</strong></td></tr><tr><td align="left"><strong>Ctrl+Alt+I</strong></td><td align="left"><strong>自动优化代码缩进</strong></td></tr><tr><td align="left"><strong>Tab&#x2F;Shift+Tab</strong></td><td align="left"><strong>缩进代码&#x2F;取消缩进代码</strong></td></tr><tr><td align="left"><strong>Ctrl+X or Shift+Delete</strong></td><td align="left"><strong>剪切代码，未选择代码时剪切当前行</strong></td></tr><tr><td align="left"><strong>Ctrl+C or Ctrl+Insert</strong></td><td align="left"><strong>复制代码，未选择代码时复制当前行</strong></td></tr><tr><td align="left"><strong>Ctrl+V or Shift+Insert</strong></td><td align="left"><strong>粘贴代码</strong></td></tr><tr><td align="left"><strong>Ctrl+Shift+V</strong></td><td align="left"><strong>粘贴最近复制的内容</strong></td></tr><tr><td align="left"><strong>Ctrl+D</strong></td><td align="left"><strong>重复代码，未选择代码时重复当前行</strong></td></tr><tr><td align="left"><strong>Ctrl+Y</strong></td><td align="left"><strong>删除行，未选择时删除当前行</strong></td></tr><tr><td align="left"><strong>Ctrl+Shift+J</strong></td><td align="left"><strong>合并多行为一行</strong></td></tr><tr><td align="left"><strong>Ctrl+Enter</strong></td><td align="left"><strong>分割一行为多行</strong></td></tr><tr><td align="left"><strong>Shift+Enter</strong></td><td align="left"><strong>使光标所在位置的下一行为新行</strong></td></tr><tr><td align="left"><strong>Ctrl+Shift+U</strong></td><td align="left"><strong>对选中内容进行大小写切换</strong></td></tr><tr><td align="left"><strong>Ctrl+Shift+]&#x2F;[</strong></td><td align="left"><strong>选中到代码块的开始&#x2F;结束</strong></td></tr><tr><td align="left"><strong>Ctrl+Delete</strong></td><td align="left"><strong>删除从光标所在位置到单词结束位置的字符</strong></td></tr><tr><td align="left"><strong>Ctrl+Backspace</strong></td><td align="left"><strong>删除从单词起始位置到光标所在位置的字符</strong></td></tr><tr><td align="left"><strong>Ctrl+NumPad+&#x2F;-</strong></td><td align="left"><strong>展开或收起代码块</strong></td></tr><tr><td align="left"><strong>Ctrl+Shift+NumPad+</strong></td><td align="left"><strong>展开所有代码块</strong></td></tr><tr><td align="left"><strong>Ctrl+Shift+NumPad-</strong></td><td align="left"><strong>收起所有代码块</strong></td></tr><tr><td align="left"><strong>Ctrl+F4</strong></td><td align="left"><strong>关闭当前编辑页</strong></td></tr><tr><td align="left"><strong>CTRL+ALT+B</strong></td><td align="left"><strong>查找接口的实现类</strong></td></tr><tr><td align="left"><strong>CTRL+ALT+SHIFT+C</strong></td><td align="left"><strong>复制类的全类名</strong></td></tr></tbody></table><h3 id="2-Search-x2F-Replace-查找-x2F-替换"><a href="#2-Search-x2F-Replace-查找-x2F-替换" class="headerlink" title="2. Search&#x2F;Replace(查找&#x2F;替换)"></a><strong>2. Search&#x2F;Replace(查找&#x2F;替换)</strong></h3><table><thead><tr><th align="left"><strong>快捷键</strong></th><th align="left"><strong>介绍</strong></th></tr></thead><tbody><tr><td align="left"><strong>Double Shift</strong></td><td align="left"><strong>Search everywhere</strong></td></tr><tr><td align="left"><strong>Ctrl+F</strong></td><td align="left"><strong>查找</strong></td></tr><tr><td align="left"><strong>F3</strong></td><td align="left"><strong>查找下一个</strong></td></tr><tr><td align="left"><strong>Shift+F3</strong></td><td align="left"><strong>查找上一个</strong></td></tr><tr><td align="left"><strong>Ctrl+R</strong></td><td align="left"><strong>替换</strong></td></tr><tr><td align="left"><strong>Ctrl+Shift+F</strong></td><td align="left"><strong>目录内查找</strong></td></tr><tr><td align="left"><strong>Ctrl+Shift+R</strong></td><td align="left"><strong>目录内替换</strong></td></tr><tr><td align="left"><strong>Ctrl+Shift+S</strong></td><td align="left"><strong>语法模板搜索</strong></td></tr><tr><td align="left"><strong>Ctrl+Shift+M</strong></td><td align="left"><strong>语法模板替换</strong></td></tr></tbody></table><h3 id="3-Usage-Search-使用搜索"><a href="#3-Usage-Search-使用搜索" class="headerlink" title="3. Usage Search(使用搜索)"></a><strong>3. Usage Search(使用搜索)</strong></h3><table><thead><tr><th align="left"><strong>快捷键</strong></th><th align="left"><strong>介绍</strong></th></tr></thead><tbody><tr><td align="left"><strong>Alt+F7</strong></td><td align="left"><strong>查找被使用处</strong></td></tr><tr><td align="left"><strong>Ctrl+F7</strong></td><td align="left"><strong>查找当前文件中的使用处</strong></td></tr><tr><td align="left"><strong>Ctrl+Shift+F7</strong></td><td align="left"><strong>高亮当前文件中的使用处</strong></td></tr><tr><td align="left"><strong>Ctrl+Alt+F7</strong></td><td align="left"><strong>列出使用者</strong></td></tr></tbody></table><h3 id="4-Compile-and-Run-编译-x2F-运行"><a href="#4-Compile-and-Run-编译-x2F-运行" class="headerlink" title="4. Compile and Run(编译&#x2F;运行)"></a><strong>4. Compile and Run(编译&#x2F;运行)</strong></h3><table><thead><tr><th align="left"><strong>快捷键</strong></th><th align="left"><strong>介绍</strong></th></tr></thead><tbody><tr><td align="left"><strong>Ctrl+F9</strong></td><td align="left"><strong>Make 模块、项目</strong></td></tr><tr><td align="left"><strong>Ctrl+Shift+F9</strong></td><td align="left"><strong>编译选中的文件、模块、项目</strong></td></tr><tr><td align="left"><strong>Alt+Shift+F10</strong></td><td align="left"><strong>选择配置后运行代码</strong></td></tr><tr><td align="left"><strong>Alt+Shift+F9</strong></td><td align="left"><strong>选择配置后调试代码</strong></td></tr><tr><td align="left"><strong>Shift+F10</strong></td><td align="left"><strong>运行代码</strong></td></tr><tr><td align="left"><strong>Shift+F9</strong></td><td align="left"><strong>调试代码</strong></td></tr><tr><td align="left"><strong>Ctrl+F2</strong></td><td align="left"><strong>停止调试</strong></td></tr><tr><td align="left"><strong>Ctrl+Shift+F10</strong></td><td align="left"><strong>运行代码</strong></td></tr></tbody></table><h3 id="5-Debugging-调试"><a href="#5-Debugging-调试" class="headerlink" title="5. Debugging(调试)"></a><strong>5. Debugging(调试)</strong></h3><table><thead><tr><th align="left"><strong>快捷键</strong></th><th align="left"><strong>介绍</strong></th></tr></thead><tbody><tr><td align="left"><strong>F8</strong></td><td align="left"><strong>单步调试，不进入函数内部</strong></td></tr><tr><td align="left"><strong>F7</strong></td><td align="left"><strong>单步调试，进入函数内部</strong></td></tr><tr><td align="left"><strong>Shift+F7&#x2F;Alt+Shift+F7</strong></td><td align="left"><strong>选择要进入的函数&#x2F;强制进入函数</strong></td></tr><tr><td align="left"><strong>Shift+F8</strong></td><td align="left"><strong>跳出函数</strong></td></tr><tr><td align="left"><strong>Alt+F9</strong></td><td align="left"><strong>运行到断点</strong></td></tr><tr><td align="left"><strong>Alt+F8</strong></td><td align="left"><strong>执行表达式查看结果</strong></td></tr><tr><td align="left"><strong>F9</strong></td><td align="left"><strong>继续执行，进入下一个断点或执行完程序</strong></td></tr><tr><td align="left"><strong>Ctrl+F8</strong></td><td align="left"><strong>设置&#x2F;取消当前行断点</strong></td></tr><tr><td align="left"><strong>Ctrl+Shift+F8</strong></td><td align="left"><strong>查看断点</strong></td></tr></tbody></table><h3 id="6-Navigation-导航"><a href="#6-Navigation-导航" class="headerlink" title="6. Navigation(导航)"></a><strong>6. Navigation(导航)</strong></h3><table><thead><tr><th align="left"><strong>快捷键</strong></th><th align="left"><strong>介绍</strong></th></tr></thead><tbody><tr><td align="left"><strong>Double Shift</strong></td><td align="left"><strong>查找所有</strong></td></tr><tr><td align="left"><strong>Ctrl+N</strong></td><td align="left"><strong>查找类</strong></td></tr><tr><td align="left"><strong>Ctrl+Shift+N</strong></td><td align="left"><strong>查找文件</strong></td></tr><tr><td align="left"><strong>Ctrl+Alt+Shift+N</strong></td><td align="left"><strong>Go to symbol</strong></td></tr><tr><td align="left"><strong>Alt+Right&#x2F;Left</strong></td><td align="left"><strong>左右切换 Tab</strong></td></tr><tr><td align="left"><strong>F12</strong></td><td align="left"><strong>回到上一个打开的窗口</strong></td></tr><tr><td align="left"><strong>Esc</strong></td><td align="left"><strong>焦点回到编辑器</strong></td></tr><tr><td align="left"><strong>Shift+Esc</strong></td><td align="left"><strong>隐藏打开的视图</strong></td></tr><tr><td align="left"><strong>Ctrl+Shift+F4</strong></td><td align="left"><strong>关闭当前 Tab</strong></td></tr><tr><td align="left"><strong>Ctrl+G</strong></td><td align="left"><strong>跳到指定行</strong></td></tr><tr><td align="left"><strong>Ctrl+E</strong></td><td align="left"><strong>显示最近打开的文件</strong></td></tr><tr><td align="left"><strong>Ctrl+Alt+Left</strong></td><td align="left"><strong>跳到光标的上一个位置</strong></td></tr><tr><td align="left"><strong>Ctrl+Alt+Right</strong></td><td align="left"><strong>跳到光标的下一个位置</strong></td></tr><tr><td align="left"><strong>Ctrl+Shift+Backspace</strong></td><td align="left"><strong>跳到上一个编辑处</strong></td></tr><tr><td align="left"><strong>Alt+F1</strong></td><td align="left"><strong>选择当前文件显示在不同的视图中</strong></td></tr><tr><td align="left"><strong>Ctrl+B or Ctrl+Click</strong></td><td align="left"><strong>跳到类声明处</strong></td></tr><tr><td align="left"><strong>Ctrl+Alt+B</strong></td><td align="left"><strong>跳到实现类&#x2F;方法</strong></td></tr><tr><td align="left"><strong>Ctrl+Shift+I</strong></td><td align="left"><strong>显示类&#x2F;变量&#x2F;方法定义</strong></td></tr><tr><td align="left"><strong>Ctrl+Shift+B</strong></td><td align="left"><strong>跳到类型定义处</strong></td></tr><tr><td align="left"><strong>Ctrl+U</strong></td><td align="left"><strong>跳到父类&#x2F;方法</strong></td></tr><tr><td align="left"><strong>Alt+Up</strong></td><td align="left"><strong>光标移动到上一个方法</strong></td></tr><tr><td align="left"><strong>Alt+Down</strong></td><td align="left"><strong>光标移动到下一个方法</strong></td></tr><tr><td align="left"><strong>Ctrl+]</strong></td><td align="left"><strong>光标移动到代码块的起始位置</strong></td></tr><tr><td align="left"><strong>Ctrl+]</strong></td><td align="left"><strong>光标移动到代码块的结束位置</strong></td></tr><tr><td align="left"><strong>Ctrl+F12</strong></td><td align="left"><strong>显示文件结构</strong></td></tr><tr><td align="left"><strong>Ctrl+H</strong></td><td align="left"><strong>显示类层级</strong></td></tr><tr><td align="left"><strong>Ctrl+Shift+H</strong></td><td align="left"><strong>显示方法层级</strong></td></tr><tr><td align="left"><strong>Ctrl+Alt+H</strong></td><td align="left"><strong>显示类&#x2F;方法调用层级</strong></td></tr><tr><td align="left"><strong>F2</strong></td><td align="left"><strong>光标移动到下一个错误</strong></td></tr><tr><td align="left"><strong>Shift+F2</strong></td><td align="left"><strong>标移动到上一个错误</strong></td></tr><tr><td align="left"><strong>F4</strong></td><td align="left"><strong>编辑源码，光标移到编辑器内</strong></td></tr><tr><td align="left"><strong>Ctrl+Enter</strong></td><td align="left"><strong>查看源码，光标没移到编辑器内</strong></td></tr><tr><td align="left"><strong>Alt+Home</strong></td><td align="left"><strong>显示导航面包屑</strong></td></tr><tr><td align="left"><strong>F11</strong></td><td align="left"><strong>当前行设置书签</strong></td></tr><tr><td align="left"><strong>Shift+F11</strong></td><td align="left"><strong>显示所有书签</strong></td></tr><tr><td align="left"><strong>Ctrl+F11</strong></td><td align="left"><strong>设置书签号[0-9]</strong></td></tr><tr><td align="left"><strong>Ctrl+[0-9]</strong></td><td align="left"><strong>跳到书签号[0-9]所在位置</strong></td></tr></tbody></table><h3 id="7-Refactoring-重构"><a href="#7-Refactoring-重构" class="headerlink" title="7. Refactoring(重构)"></a><strong>7. Refactoring(重构)</strong></h3><table><thead><tr><th align="left"><strong>快捷键</strong></th><th align="left"><strong>介绍</strong></th></tr></thead><tbody><tr><td align="left"><strong>F5</strong></td><td align="left"><strong>复制类</strong></td></tr><tr><td align="left"><strong>F6</strong></td><td align="left"><strong>移动类</strong></td></tr><tr><td align="left"><strong>Alt+Delete</strong></td><td align="left"><strong>安全删除，删除前会提示调用处</strong></td></tr><tr><td align="left"><strong>Shift+F6</strong></td><td align="left"><strong>重命名</strong></td></tr><tr><td align="left"><strong>Ctrl+F6</strong></td><td align="left"><strong>重构方法参数、Exception 等</strong></td></tr><tr><td align="left"><strong>Ctrl+Alt+N</strong></td><td align="left"><strong>合并多行为一行</strong></td></tr><tr><td align="left"><strong>Ctrl+Alt+M</strong></td><td align="left"><strong>提取为新方法</strong></td></tr><tr><td align="left"><strong>Ctrl+Alt+V</strong></td><td align="left"><strong>提取为新变量</strong></td></tr><tr><td align="left"><strong>Ctrl+Alt+F</strong></td><td align="left"><strong>提取为对象新属性</strong></td></tr><tr><td align="left"><strong>Ctrl+Alt+C</strong></td><td align="left"><strong>提取为新静态常量</strong></td></tr><tr><td align="left"><strong>Ctrl+Alt+P</strong></td><td align="left"><strong>提取参数</strong></td></tr></tbody></table><h3 id="8-VCS-x2F-Local-History-版本控制-x2F-本地历史"><a href="#8-VCS-x2F-Local-History-版本控制-x2F-本地历史" class="headerlink" title="8. VCS&#x2F;Local History(版本控制&#x2F;本地历史)"></a><strong>8. VCS&#x2F;Local History(版本控制&#x2F;本地历史)</strong></h3><table><thead><tr><th align="left"><strong>快捷键</strong></th><th align="left"><strong>介绍</strong></th></tr></thead><tbody><tr><td align="left"><strong>Ctrl+K</strong></td><td align="left"><strong>提交改动到 VCS</strong></td></tr><tr><td align="left"><strong>Ctrl+T</strong></td><td align="left"><strong>从 VCS 上更新</strong></td></tr><tr><td align="left"><strong>Alt+Shift+C</strong></td><td align="left"><strong>查看最近的改动记录</strong></td></tr><tr><td align="left"><strong>Alt+BackQuote(&#96;)</strong></td><td align="left"><strong>显示 VCS 操作列表</strong></td></tr></tbody></table><h3 id="9-Live-Templates-动态模板"><a href="#9-Live-Templates-动态模板" class="headerlink" title="9. Live Templates(动态模板)"></a><strong>9. Live Templates(动态模板)</strong></h3><table><thead><tr><th align="left"><strong>快捷键</strong></th><th align="left"><strong>介绍</strong></th></tr></thead><tbody><tr><td align="left"><strong>Ctrl+Alt+J</strong></td><td align="left"><strong>使用 Live Template 包围选中代码</strong></td></tr><tr><td align="left"><strong>Ctrl+J</strong></td><td align="left"><strong>快速插入 Live Template</strong></td></tr><tr><td align="left"><strong>iter</strong></td><td align="left"><strong>快速生成 for…in 语句</strong></td></tr><tr><td align="left"><strong>inst</strong></td><td align="left"><strong>快速生成”if instanceof ”语句</strong></td></tr><tr><td align="left"><strong>itco</strong></td><td align="left"><strong>快速生成 iterator 的 for 循环</strong></td></tr><tr><td align="left"><strong>itit</strong></td><td align="left"><strong>快速生成 iterator 的 while 循环</strong></td></tr><tr><td align="left"><strong>itli</strong></td><td align="left"><strong>快速生成 list 的 for(i)循环</strong></td></tr><tr><td align="left"><strong>psf</strong></td><td align="left"><strong>快速生成“public static final” 语句</strong></td></tr><tr><td align="left"><strong>thr</strong></td><td align="left"><strong>快速生成“throw new” 语句</strong></td></tr></tbody></table><h3 id="10-General-代码生成"><a href="#10-General-代码生成" class="headerlink" title="10. General(代码生成)"></a><strong>10. General(代码生成)</strong></h3><table><thead><tr><th align="left"><strong>快捷键</strong></th><th align="left"><strong>介绍</strong></th></tr></thead><tbody><tr><td align="left"><strong>Alt+0</strong></td><td align="left"><strong>聚焦到 Messages 窗口</strong></td></tr><tr><td align="left"><strong>Alt+1</strong></td><td align="left"><strong>聚焦到 Project 窗口</strong></td></tr><tr><td align="left"><strong>Alt+2</strong></td><td align="left"><strong>聚焦到 Favorite 窗口</strong></td></tr><tr><td align="left"><strong>Alt+3</strong></td><td align="left"><strong>聚焦到 Find 窗口</strong></td></tr><tr><td align="left"><strong>Alt+4</strong></td><td align="left"><strong>聚焦到 Run 窗口</strong></td></tr><tr><td align="left"><strong>Alt+5</strong></td><td align="left"><strong>聚焦到 Debug 窗口</strong></td></tr><tr><td align="left"><strong>Alt+6</strong></td><td align="left"><strong>聚焦到 TODO 窗口</strong></td></tr><tr><td align="left"><strong>Alt+7</strong></td><td align="left"><strong>聚焦到 Structure 窗口</strong></td></tr><tr><td align="left"><strong>Alt+8</strong></td><td align="left"><strong>聚焦到 Hierarchy 窗口</strong></td></tr><tr><td align="left"><strong>Alt+9</strong></td><td align="left"><strong>聚焦到 Change 窗口</strong></td></tr><tr><td align="left"><strong>Ctrl+S</strong></td><td align="left"><strong>保存文件</strong></td></tr><tr><td align="left"><strong>Ctrl+Alt+Y</strong></td><td align="left"><strong>与本地文件同步</strong></td></tr><tr><td align="left"><strong>Ctrl+Shift+F12</strong></td><td align="left"><strong>切换最大化编辑</strong></td></tr><tr><td align="left"><strong>Alt+Shift+F</strong></td><td align="left"><strong>添加到收藏夹</strong></td></tr><tr><td align="left"><strong>Alt+Shift+I</strong></td><td align="left"><strong>检查当前文件，包括 Javadoc 问题、可能存在的 bug 等</strong></td></tr><tr><td align="left"><strong>Ctrl+BackQuote (&#96;)</strong></td><td align="left"><strong>模式切换，包括文本外观、快捷键、编辑器外观、代码样式。</strong></td></tr><tr><td align="left"><strong>Ctrl+Alt+S</strong></td><td align="left"><strong>打开 settings 窗口</strong></td></tr><tr><td align="left"><strong>Ctrl+Alt+Shift+S</strong></td><td align="left"><strong>打开项目结构对话框</strong></td></tr><tr><td align="left"><strong>Ctrl+Shift+A</strong></td><td align="left"><strong>Find Action</strong></td></tr><tr><td align="left"><strong>Ctrl+Tab</strong></td><td align="left"><strong>选项卡和工具窗口之间切换</strong></td></tr><tr><td align="left"><strong>Alt+F12</strong></td><td align="left"><strong>打开命令终端</strong></td></tr><tr><td align="left"><strong>Shift+Shift</strong></td><td align="left"><strong>搜索文件</strong></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>StarUML激活</title>
      <link href="/2023/06/07/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/StarUML%E6%BF%80%E6%B4%BB/"/>
      <url>/2023/06/07/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/StarUML%E6%BF%80%E6%B4%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="StarUML激活"><a href="#StarUML激活" class="headerlink" title="StarUML激活"></a>StarUML激活</h1><p>确切的来说并不是激活StarUML，只是去除了StarUML在未激活时的弹窗提示</p><p>原理：对StarUML的依赖启动app.asar文件进行反编译拿到源码，把源码中未激活提示部分移除掉即可，并且关闭自动升级，避免文件被覆盖。</p><p>1、app.asar 所使用的时asar程序，那么我们需要先安装一个node，通过node下载asar应用<br>2、找到StarUML的安装目录，在安装目录的resource文件夹下有一个app.asar文件<br>3、使用asar反编译 <code>asar extract app.asar app</code>生成源代码，源代码在app文件夹内，注意：如果是在C盘的管理员目录，需要用管理员身份执行CMD。<br>4、修改<code>app\src\engine\license-manager.js</code>文件中checkLicenseValidity方法的代码  </p><pre><code class="javascript">checkLicenseValidity () &#123;    this.validate().then(() =&gt; &#123;    setStatus(this, true)    &#125;, () =&gt; &#123;    //setStatus(this,false)  &lt;-- comment this line    setStatus(this, true) //&lt;-- add this line    //UnregisteredDialog.showDialog() &lt;-- comment this line    &#125;)&#125;</code></pre><p>5、修改<code>app\src\app-context.js</code>文件的appReady方法的代码，禁止自动更新</p><pre><code class="javascript">// if (this.preferences.get(&#39;checkUpdate.checkUpdateOnStart&#39;)) &#123;//    ipcRenderer.send(&#39;check-update&#39;)// &#125;</code></pre><p>6、重新打包覆盖原来的app.asar文件 <code>asar pack app app.asar</code></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Jwt加密生成</title>
      <link href="/2023/06/07/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/Jwt%E5%8A%A0%E5%AF%86%E7%94%9F%E6%88%90/"/>
      <url>/2023/06/07/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/Jwt%E5%8A%A0%E5%AF%86%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h1 id="JWT初步使用"><a href="#JWT初步使用" class="headerlink" title="JWT初步使用"></a>JWT初步使用</h1><p><strong>POM文件导入</strong></p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.auth0&lt;/groupId&gt;    &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;    &lt;version&gt;3.10.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><strong>JWT实现类</strong></p><pre><code class="java">@Componentpublic class JwtUtils &#123;    /**     *  获取Token，签名由ID代替，形成动态签名     * @param autoDuration 超时的时间长度     * @param jwtBeanBO 用户数据     * @return token     */    public String getToken(long autoDuration, JwtBeanBO jwtBeanBO)&#123;                long outLong = System.currentTimeMillis() + autoDuration;        Date outDate = new Date(outLong);        //加密方式HS256        Algorithm algorithm = Algorithm.HMAC256(jwtBeanBO.getId().toString());        HashMap&lt;String, Object&gt; hashMap = new HashMap&lt;&gt;(5);        hashMap.put(&quot;id&quot;,jwtBeanBO.getId());        hashMap.put(&quot;userName&quot;,jwtBeanBO.getUserName());        hashMap.put(&quot;passWord&quot;,jwtBeanBO.getPassWord());        hashMap.put(&quot;userPhone&quot;,jwtBeanBO.getUserPhone());        hashMap.put(&quot;userAddress&quot;,jwtBeanBO.getUserAddress());        return JWT.create()                .withHeader(hashMap)                .withIssuer(jwtBeanBO.getUserName())                .withExpiresAt(outDate)                .sign(algorithm);    &#125;&#125;</code></pre><p><strong>具体操作见:<a href="https://github.com/auth0/java-jwt">Jwt-Github</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 开源框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Seata1.4.0安装</title>
      <link href="/2023/06/07/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/Seata1.4.0%E5%AE%89%E8%A3%85/"/>
      <url>/2023/06/07/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/Seata1.4.0%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="seata-install-1-4-0"><a href="#seata-install-1-4-0" class="headerlink" title="seata-install-1.4.0"></a>seata-install-1.4.0</h1><p>基于seata 1.4.2 实现，涉及到的外部文件有：</p><ul><li>server 端的 sql 文件</li><li>client 端的 sql 文件</li><li>nacos-config.sh 执行脚本</li><li>config.txt 执行配置文件<br>这些文件修改成了，conf下的 REDEME.md &#x2F; REDEME-zh.md 文件内描述内容，给了所有文件的下载链接，直接查阅该文件即可</li></ul><hr><p><strong>开始配置</strong><br><a href="https://seata.io/zh-cn/docs/user/configurations.html">官网参数详情</a><br><a href="https://github.com/seata/seata/blob/develop/script">Github上Seata的外部文件地址</a></p><p>server 端</p><ol><li><p>首先在 Github 下载所需版本的 Seata-Server 二进制包，并且在服务器解压</p></li><li><p>下载数据库文件，这里我们选择MySQL，并且在MySQL数据库中创建一个数据库，并且执行下载下来的数据库文件</p></li><li><p>修改conf目录下的register.conf文件，首先必要修改的是register部分，register部分为seata-server服务启动之后的注册模式（file 、nacos 、eureka、redis、zk、consul、etcd3、sofa），这里我们选择的是nacos，配置如下：</p><pre><code class="conf">registry &#123;   # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa   type = &quot;nacos&quot;   nacos &#123;     application = &quot;seata-server&quot;     serverAddr = &quot;192.168.246.105:8848&quot;     group = &quot;SEATA_GROUP&quot;     namespace = &quot;8b191ab1-8b24-4ea1-be79-5f1668e9046c&quot;     cluster = &quot;default&quot;     username = &quot;nacos&quot;     password = &quot;nacos&quot;   &#125; &#125;</code></pre></li><li><p>选贼seata-server服务端的配置文件模式（file、nacos 、apollo、zk、consul、etcd3），如果是选择file就需要同目录下的file.conf文件，作为配置文件，这里我们选择nacos，配置如下：</p><pre><code class="conf">config &#123;   # file、nacos 、apollo、zk、consul、etcd3   type = &quot;nacos&quot;   nacos &#123;     serverAddr = &quot;192.168.246.105:8848&quot;     namespace = &quot;8b191ab1-8b24-4ea1-be79-5f1668e9046c&quot;     group = &quot;SEATA_GROUP&quot;     username = &quot;nacos&quot;     password = &quot;nacos&quot;     dataId = &quot;seataServer.properties&quot;   &#125; &#125;</code></pre></li><li><p>基于第四步选择的config模式，需要在指定的namespance创建dataId所指定的配置文件，配置文件的内容则是config.txt的内容，修改成需要的数据就好了，下面是我修改的部分，配置如下：</p><pre><code class="properties"> # 修改事务分组，glcxw_tx_group 是分组，default集群名称 service.vgroupMapping.glcxw_tx_group=default # 选择配置模式 store.mode=db store.lock.mode=db store.session.mode=db # db的配置 store.db.datasource=druid store.db.dbType=mysql store.db.driverClassName=com.mysql.cj.jdbc.Driver store.db.url=jdbc:mysql://192.168.246.107:3306/seata?useUnicode=true&amp;rewriteBatchedStatements=true store.db.user=glcxw store.db.password=glcxw_yyds</code></pre></li><li><p>还需要下载nacos-config.sh脚本文件，然后将修改好的config.txt放在脚本的父目录，例如脚本在conf下，config.txt在seata根目录，执行下面的命令，把每一项添加到nacos，为后面client使用</p><pre><code class="shell"> sh nacos_config.sh -t 8b191ab1-8b24-4ea1-be79-5f1668e9046c -h 192.168.246.105</code></pre></li><li><p>在seata-server的bin目录下执行如下命令，把seata-server注册到nacos中，并且指定访问地址和打开的端口</p><pre><code class="shell"> sh seata-server.sh -h 192.168.246.110 -p 8091</code></pre></li><li><p>服务端到此配置完成</p></li></ol><p>client 端</p><p><a href="https://seata.io/zh-cn/docs/user/configuration/nacos.html">Nacos 配置中心</a></p><p><a href="https://seata.io/zh-cn/docs/user/registry/index.html">Nacos 注册中心</a></p><p>首先按照官方的参照文档需要依赖如下文件</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;io.seata&lt;/groupId&gt;    &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;最新版&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;    &lt;artifactId&gt;nacos-client&lt;/artifactId&gt;    &lt;version&gt;1.2.0及以上版本&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>这里我们用的是springcloud组合seata，因为<code>seata-spring-boot-starter</code>默认带的是1.0.0的seata所以我排除默认的，导入了新的seata 1.4.2</p><pre><code class="xml"> &lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt;            &lt;groupId&gt;io.seata&lt;/groupId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.seata&lt;/groupId&gt;    &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.4.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><ol><li><p>创建本地数据库中的<code>undo_log</code>表，在REDEME-zh.md中有提及</p></li><li><p>配置yaml文件</p><pre><code class="yaml">seata: enabled: true enable-auto-data-source-proxy: true tx-service-group: glcxw_tx_group service:   vgroup-mapping:     glcxw_tx_group: default   disable-global-transaction: false registry:   type: nacos   nacos:     application: seata-server     server-addr: 192.168.246.105:8848     namespace: 8b191ab1-8b24-4ea1-be79-5f1668e9046c     group: SEATA_GROUP     username: nacos     password: nacos     cluster: default config:   type: nacos   nacos:     server-addr: 192.168.246.105:8848     namespace: 8b191ab1-8b24-4ea1-be79-5f1668e9046c     group: SEATA_GROUP     username: nacos     password: nacos     data-id: seataServer.properties</code></pre></li><li><p>在业务中使用全局事务</p><pre><code class="java">@GlobalTransactional(rollbackFor = Exception.class)@Overridepublic CommonResult&lt;String&gt; create(Integer id) &#123;    SeataOrder entity = new SeataOrder(1L, 1L, 1L, 1, 1F, 1);    int insert = baseMapper.insert(entity);    if (id == 1) throw new RuntimeException(&quot;故意抛出&quot;);    return new CommonResult&lt;String&gt;(200, &quot;SUCCESS&quot;, &quot;插入成功&quot; + entity.toString());&#125;</code></pre></li><li><p>如果feign调用的服务使用了全局异常处理，那么处理好的异常会让调用端认为异常已经处理好了，业务为正常不需要回滚全局事务，所以我们需要自定义feign的decoder，在全局异常处理完后对返回的数据进行判断，如果业务失败就抛出一个异常，让全局事务检测到，feign的降级也是如此，decoder代码如下：</p><pre><code class="java">      @Slf4j @Configuration @Primary public class ResultStatusDecoder implements Decoder &#123;     final Decoder decoder;     public ResultStatusDecoder(Decoder decoder) &#123;         this.decoder = decoder;     &#125;     @Override     public Object decode(Response response, Type type) throws IOException, DecodeException, FeignException &#123;         String resultStr = response.body().toString();         Integer code = JSONObject.parseObject(resultStr).getInteger(&quot;code&quot;);         if (code != 0) &#123;             throw new RuntimeException(&quot;seatA feign rollback&quot;);         &#125;         return decoder.decode(response.toBuilder().body(resultStr, StandardCharsets.UTF_8).build(), type);     &#125; &#125;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开源框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Seata分布式事务框架</title>
      <link href="/2023/06/07/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/Seata%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A1%86%E6%9E%B6/"/>
      <url>/2023/06/07/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/Seata%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-分布式事务框架Seatadate-2022-03-29-09-30-44-544updated-2022-10-13-15-11-45-326url-x2F-archives-x2F-fen-bu-shi-shi-wu-kuang-jia-seatacategories-Seatatags-Seata"><a href="#title-分布式事务框架Seatadate-2022-03-29-09-30-44-544updated-2022-10-13-15-11-45-326url-x2F-archives-x2F-fen-bu-shi-shi-wu-kuang-jia-seatacategories-Seatatags-Seata" class="headerlink" title="title: 分布式事务框架Seatadate: 2022-03-29 09:30:44.544updated: 2022-10-13 15:11:45.326url: &#x2F;archives&#x2F;fen-bu-shi-shi-wu-kuang-jia-seatacategories:- Seatatags:- Seata"></a>title: 分布式事务框架Seata<br>date: 2022-03-29 09:30:44.544<br>updated: 2022-10-13 15:11:45.326<br>url: &#x2F;archives&#x2F;fen-bu-shi-shi-wu-kuang-jia-seata<br>categories:<br>- Seata<br>tags:<br>- Seata</h2><p>基于seata 1.4.2 实现，涉及到的外部文件有：</p><ul><li>server 端的 sql 文件</li><li>client 端的 sql 文件</li><li>nacos-config.sh 执行脚本</li><li>config.txt 执行配置文件<br>这些文件修改成了，conf下的 REDEME.md &#x2F; REDEME-zh.md 文件内描述内容，给了所有文件的下载链接，直接查阅该文件即可</li></ul><hr><p><strong>开始配置</strong><br><a href="https://seata.io/zh-cn/docs/user/configurations.html">官网参数详情</a><br><a href="https://github.com/seata/seata/blob/develop/script">Github上Seata的外部文件地址</a></p><p>server 端</p><ol><li><p>首先在 Github 下载所需版本的 Seata-Server 二进制包，并且在服务器解压</p></li><li><p>下载数据库文件，这里我们选择MySQL，并且在MySQL数据库中创建一个数据库，并且执行下载下来的数据库文件</p></li><li><p>修改conf目录下的register.conf文件，首先必要修改的是register部分，register部分为seata-server服务启动之后的注册模式（file 、nacos 、eureka、redis、zk、consul、etcd3、sofa），这里我们选择的是nacos，配置如下：</p><pre><code class="conf">registry &#123;   # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa   type = &quot;nacos&quot;   nacos &#123;     application = &quot;seata-server&quot;     serverAddr = &quot;192.168.246.105:8848&quot;     group = &quot;SEATA_GROUP&quot;     namespace = &quot;8b191ab1-8b24-4ea1-be79-5f1668e9046c&quot;     cluster = &quot;default&quot;     username = &quot;nacos&quot;     password = &quot;nacos&quot;   &#125; &#125;</code></pre></li><li><p>选贼seata-server服务端的配置文件模式（file、nacos 、apollo、zk、consul、etcd3），如果是选择file就需要同目录下的file.conf文件，作为配置文件，这里我们选择nacos，配置如下：</p><pre><code class="conf">config &#123;   # file、nacos 、apollo、zk、consul、etcd3   type = &quot;nacos&quot;   nacos &#123;     serverAddr = &quot;192.168.246.105:8848&quot;     namespace = &quot;8b191ab1-8b24-4ea1-be79-5f1668e9046c&quot;     group = &quot;SEATA_GROUP&quot;     username = &quot;nacos&quot;     password = &quot;nacos&quot;     dataId = &quot;seataServer.properties&quot;   &#125; &#125;</code></pre></li><li><p>基于第四步选择的config模式，需要在指定的namespance创建dataId所指定的配置文件，配置文件的内容则是config.txt的内容，修改成需要的数据就好了，下面是我修改的部分，配置如下：</p><pre><code class="properties"> # 修改事务分组，glcxw_tx_group 是分组，default集群名称 service.vgroupMapping.glcxw_tx_group=default # 选择配置模式 store.mode=db store.lock.mode=db store.session.mode=db # db的配置 store.db.datasource=druid store.db.dbType=mysql store.db.driverClassName=com.mysql.cj.jdbc.Driver store.db.url=jdbc:mysql://192.168.246.107:3306/seata?useUnicode=true&amp;rewriteBatchedStatements=true store.db.user=glcxw store.db.password=glcxw_yyds</code></pre></li><li><p>还需要下载nacos-config.sh脚本文件，然后将修改好的config.txt放在脚本的父目录，例如脚本在conf下，config.txt在seata根目录，执行下面的命令，把每一项添加到nacos，为后面client使用</p><pre><code class="shell"> sh nacos_config.sh -t 8b191ab1-8b24-4ea1-be79-5f1668e9046c -h 192.168.246.105</code></pre></li><li><p>在seata-server的bin目录下执行如下命令，把seata-server注册到nacos中，并且指定访问地址和打开的端口</p><pre><code class="shell"> sh seata-server.sh -h 192.168.246.110 -p 8091</code></pre></li><li><p>服务端到此配置完成</p></li></ol><p>client 端</p><p><a href="https://seata.io/zh-cn/docs/user/configuration/nacos.html">Nacos 配置中心</a></p><p><a href="https://seata.io/zh-cn/docs/user/registry/index.html">Nacos 注册中心</a></p><p>首先按照官方的参照文档需要依赖如下文件</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;io.seata&lt;/groupId&gt;    &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;最新版&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;    &lt;artifactId&gt;nacos-client&lt;/artifactId&gt;    &lt;version&gt;1.2.0及以上版本&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>这里我们用的是springcloud组合seata，因为<code>seata-spring-boot-starter</code>默认带的是1.0.0的seata所以我排除默认的，导入了新的seata 1.4.2</p><pre><code class="xml"> &lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt;            &lt;groupId&gt;io.seata&lt;/groupId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.seata&lt;/groupId&gt;    &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.4.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><ol><li><p>创建本地数据库中的<code>undo_log</code>表，在REDEME-zh.md中有提及</p></li><li><p>配置yaml文件</p><pre><code class="yaml">seata: enabled: true enable-auto-data-source-proxy: true tx-service-group: glcxw_tx_group service:   vgroup-mapping:     glcxw_tx_group: default   disable-global-transaction: false registry:   type: nacos   nacos:     application: seata-server     server-addr: 192.168.246.105:8848     namespace: 8b191ab1-8b24-4ea1-be79-5f1668e9046c     group: SEATA_GROUP     username: nacos     password: nacos     cluster: default config:   type: nacos   nacos:     server-addr: 192.168.246.105:8848     namespace: 8b191ab1-8b24-4ea1-be79-5f1668e9046c     group: SEATA_GROUP     username: nacos     password: nacos     data-id: seataServer.properties</code></pre></li><li><p>在业务中使用全局事务</p><pre><code class="java">@GlobalTransactional(rollbackFor = Exception.class)@Overridepublic CommonResult&lt;String&gt; create(Integer id) &#123;    SeataOrder entity = new SeataOrder(1L, 1L, 1L, 1, 1F, 1);    int insert = baseMapper.insert(entity);    if (id == 1) throw new RuntimeException(&quot;故意抛出&quot;);    return new CommonResult&lt;String&gt;(200, &quot;SUCCESS&quot;, &quot;插入成功&quot; + entity.toString());&#125;</code></pre></li><li><p>如果feign调用的服务使用了全局异常处理，那么处理好的异常会让调用端认为异常已经处理好了，业务为正常不需要回滚全局事务，所以我们需要自定义feign的decoder，在全局异常处理完后对返回的数据进行判断，如果业务失败就抛出一个异常，让全局事务检测到，feign的降级也是如此，decoder代码如下：</p><pre><code class="java">      @Slf4j @Configuration @Primary public class ResultStatusDecoder implements Decoder &#123;     final Decoder decoder;     public ResultStatusDecoder(Decoder decoder) &#123;         this.decoder = decoder;     &#125;     @Override     public Object decode(Response response, Type type) throws IOException, DecodeException, FeignException &#123;         String resultStr = response.body().toString();         Integer code = JSONObject.parseObject(resultStr).getInteger(&quot;code&quot;);         if (code != 0) &#123;             throw new RuntimeException(&quot;seatA feign rollback&quot;);         &#125;         return decoder.decode(response.toBuilder().body(resultStr, StandardCharsets.UTF_8).build(), type);     &#125; &#125;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开源框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot中MySQL连接超时</title>
      <link href="/2023/06/07/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/SpringBoot%E4%B8%ADMySQL%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6/"/>
      <url>/2023/06/07/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/SpringBoot%E4%B8%ADMySQL%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot中MySQL链接超时"><a href="#SpringBoot中MySQL链接超时" class="headerlink" title="SpringBoot中MySQL链接超时"></a>SpringBoot中MySQL链接超时</h1><p>springboot项目启动开始可以访问数据库，但是几分钟之后就会报错 </p><pre><code class="java">Failed to validate connection com.mysql.cj.jdbc.ConnectionImpl</code></pre><p>由于在使用SpringBoot连接数据库的时候，会建立一个和数据库的连接，这个连接保存在数据库连接池中，而现在这个连接已经Time Out已经不可用了，但是你的连接还是保存在连接池中，SpringBoot还是使用这个连接去连接数据库，所以造成警告信息  </p><p>那么知道了原因，我们怎么解决这个问题呢，首先要知道我们可以设置连接在连接池中的存活时间，什么是连接的存活时间呢，简而言之就是你这个连接要保存在连接池中多长时间才被清除，如果你连接时间设置是五分钟，那么这个连接在三分钟的时候timeout了还是得再等两分钟才能被清除  </p><p>那么问题就很明了，你的连接在三分钟的时候就已经和数据库断开了连接，但是你默认连接的存活时间是五分钟，所以导致你的springboot项目开始能访问数据库，一会之后就不能访问数据库了  </p><p>解决方案<br>那么这样，假设说连接在三分钟的时候和数据库断开了连接，我们设置连接的存活时间是两分钟，连接就一直处于可用状态，当两分钟之后你再次访问数据库，就会new一个连接，这个连接在其生命周期内仍然是可用的  </p><pre><code class="yaml">spring  datasource    hikari:      max-lifetime: 60000 #最大存活时间      idle-timeout: 60000 #空闲连接时间      connection-timeout: 50000 #连接超时时间      maximum-pool-size: 60 #连接池最大数      minimum-idle: 10 #连接池最小数</code></pre>]]></content>
      
      
      <categories>
          
          <category> 开源框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合Kafka</title>
      <link href="/2023/06/07/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/SpringBoot%E6%95%B4%E5%90%88Kafka/"/>
      <url>/2023/06/07/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/SpringBoot%E6%95%B4%E5%90%88Kafka/</url>
      
        <content type="html"><![CDATA[<p>引入Spring-Kafka的POM依赖</p><pre><code class="promql">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;    &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>配置<code>application.properties</code>信息</p><pre><code class="properties">spring.kafka.bootstrap-servers=10.254.0.2:9092spring.kafka.consumer.group-id=multiple-consumer-groupspring.kafka.consumer.auto-offset-reset=earliest</code></pre><p>配置Kafka的Topic</p><pre><code class="java">/** * @author huangJie * @version 1.0v * @date 2022/10/19 9:49 */@Configurationpublic class KafkaConfig &#123;    @Bean    NewTopic multipleTopic() &#123;        return TopicBuilder.name(&quot;multiple-topic&quot;).build();    &#125;&#125;</code></pre><p>编写KafkaTemplate使用的Service</p><pre><code class="java">/** * @author huangJie * @version 1.0v * @date 2022/10/19 10:01 */@Slf4j@Servicepublic class KafkaServiceImpl implements KafkaService &#123;    @Resource    private KafkaTemplate&lt;String, String&gt; kafkaTemplate;    @Resource    private CustomListenableFutureCallback futureCallback;    @Override    public void send(String topic, String message) &#123;        try &#123;            ListenableFuture&lt;SendResult&lt;String, String&gt;&gt; send = kafkaTemplate.send(topic, message);            send.addCallback(futureCallback);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>消息发送回调</p><pre><code class="java">/** * @author huangJie * @version 1.0v * @date 2022/10/19 14:10 */@Slf4j@Componentpublic class CustomListenableFutureCallback implements ListenableFutureCallback&lt;SendResult&lt;String, String&gt;&gt; &#123;    @Override    public void onFailure(@Nullable Throwable throwable) &#123;        log.error(&quot;kafka send message error&quot;, throwable);    &#125;    @Override    public void onSuccess(SendResult&lt;String, String&gt; sendResult) &#123;        log.info(&quot;kafka send message success [&#123;&#125;]&quot;, sendResult);    &#125;&#125;</code></pre><p>配置监听</p><pre><code class="java">/** * @author huangJie * @version 1.0v * @date 2022/10/19 9:52 */@Slf4j@Component@KafkaListener(topics = &quot;multiple-topic&quot;)public class MultipleListening &#123;    @KafkaHandler    public void handler(String message) &#123;        log.info(&quot;kafka listening message [&#123;&#125;]&quot;, message);    &#125;    // @KafkaHandler    public &lt;K, V&gt; void handler0(ConsumerRecord&lt;K, V&gt; record, Acknowledgment ack, @Header(KafkaHeaders.RECEIVED_TOPIC) String topic) &#123;        log.info(&quot;kafka listening message: topic [&#123;&#125;] key [&#123;&#125;] value [&#123;&#125;]&quot;, topic, record.key(), record.value());        ack.acknowledge();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 开源框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合Zookeeper简单运用</title>
      <link href="/2023/06/07/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/SpringBoot%E6%95%B4%E5%90%88Zookeeper%E7%AE%80%E5%8D%95%E8%BF%90%E7%94%A8/"/>
      <url>/2023/06/07/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/SpringBoot%E6%95%B4%E5%90%88Zookeeper%E7%AE%80%E5%8D%95%E8%BF%90%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-SpringBoot整合Zookeeper简单运用date-2022-10-11-10-27-30-04updated-2022-10-13-14-43-42-459url-x2F-archives-x2F-spring-boot-zheng-he-zookeeper-jian-dan-yun-yongcategories-Zookeeper-SpringBoottags-SpringBoot-Zookeeper"><a href="#title-SpringBoot整合Zookeeper简单运用date-2022-10-11-10-27-30-04updated-2022-10-13-14-43-42-459url-x2F-archives-x2F-spring-boot-zheng-he-zookeeper-jian-dan-yun-yongcategories-Zookeeper-SpringBoottags-SpringBoot-Zookeeper" class="headerlink" title="title: SpringBoot整合Zookeeper简单运用date: 2022-10-11 10:27:30.04updated: 2022-10-13 14:43:42.459url: &#x2F;archives&#x2F;spring-boot-zheng-he-zookeeper-jian-dan-yun-yongcategories:- Zookeeper- SpringBoottags:- SpringBoot- Zookeeper"></a>title: SpringBoot整合Zookeeper简单运用<br>date: 2022-10-11 10:27:30.04<br>updated: 2022-10-13 14:43:42.459<br>url: &#x2F;archives&#x2F;spring-boot-zheng-he-zookeeper-jian-dan-yun-yong<br>categories:<br>- Zookeeper<br>- SpringBoot<br>tags:<br>- SpringBoot<br>- Zookeeper</h2><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>zookeeper一般作为注册中心、配置中心等使用，对于此处的使用，spring cloud zookeeper有非常完善的api，引入相对于的pom即可</p><p>而在此处是对zookeeper的基础api进行简单的运用，也就是对zookeeper的节点运用，不涉及集群操作</p><pre><code class="xml">&lt;dependency&gt;  &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;  &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p><a href="https://zookeeper.apache.org/">详情参照</a></p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>zookeeper的节点存储为树形结构，并且其存在多种节点类型，这里只简单使用了持久节点和临时节点<br>持久节点为客户端一经创建，则会永久的存在与本地文件系统，除非客户端手动删除<br>临时节点与客户端的本次连接生命周期一致，连接断掉即自动删除节点，也可手动删除</p><p>需要注意的是临时节点下不能存在子节点</p><h2 id="代码使用"><a href="#代码使用" class="headerlink" title="代码使用"></a>代码使用</h2><p>属性值</p><pre><code class="java">/** * @author huangJie * @version 1.0v * @date 2022/10/10 14:57 */@Data@Configuration@ConfigurationProperties(prefix = PropertiesPrefixConstant.ZK)public class ZkProperties &#123;    private String address;    private Integer timeout;&#125;</code></pre><p>配置: 此处的bean配置的为客户端的连接，Zookeeper的客户端对象作为单例存在于IOC容器，维持客户端连接</p><pre><code class="java">/** * @author huangJie * @version 1.0v * @date 2022/10/10 15:06 */@Configuration@ConditionalOnProperty(prefix = Constant.CONDITIONAL, name = &quot;zk&quot;, havingValue = &quot;true&quot;)public class ZookeeperConfig &#123;    private final static Logger LOGGER = LoggerFactory.getLogger(ZookeeperConfig.class);    @Resource    private ZkProperties zkProperties;    public void test()&#123;    &#125;    @Bean    public ZooKeeper zkClient() &#123;        ZooKeeper zooKeeper = null;        try &#123;            final CountDownLatch countDownLatch = new CountDownLatch(1);            zooKeeper = new ZooKeeper(zkProperties.getAddress(), zkProperties.getTimeout(), new Watcher() &#123;                @Override                public void process(WatchedEvent event) &#123;                    if (Event.KeeperState.SyncConnected == event.getState()) &#123;                        countDownLatch.countDown();                    &#125;                &#125;            &#125;);            countDownLatch.await();        &#125; catch (Exception e) &#123;            LOGGER.error(&quot;zk init client for error&quot;, e);        &#125;        return zooKeeper;    &#125;&#125;</code></pre><p>API提供者</p><pre><code class="java">/** * @author huangJie * @version 1.0v * @date 2022/10/10 15:32 */@Componentpublic class ZkProducer &#123;    private final static Logger LOGGER = LoggerFactory.getLogger(ZkProducer.class);    @Resource    private ZooKeeper zkClient;    /**     * 创建永久节点     *     * @param path 节点路径     * @param data 节点的数据     * @return true创建成功 false创建失败     */    public boolean createNode(String path, String data) &#123;        try &#123;            if (!existsNode(path)) &#123;                zkClient.create(path, data.getBytes(StandardCharsets                        .UTF_8), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            &#125;            return true;        &#125; catch (Exception e) &#123;            LOGGER.error(&quot;create zk node for error&quot;, e);        &#125;        return false;    &#125;    /**     * 创建临时节点     *     * @param path 路径     * @param data 数据     * @return true创建成功 false创建失败     */    public boolean createTmpNode(String path, String data) &#123;        try &#123;            if (!existsNode(path)) &#123;                zkClient.create(path, data.getBytes(StandardCharsets                        .UTF_8), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);            &#125;            return true;        &#125; catch (Exception e) &#123;            LOGGER.error(&quot;create zk tmp node for error&quot;, e);        &#125;        return false;    &#125;    /**     * 更新节点数据     *     * @param path 节点路径     * @param data 数据     * @return true成功 false失败     */    public boolean updateNode(String path, String data) &#123;        try &#123;            if (existsNode(path)) &#123;                zkClient.setData(path, data.getBytes(StandardCharsets.UTF_8), -1);                return true;            &#125;        &#125; catch (Exception e) &#123;            LOGGER.error(&quot;update for zk node data error&quot;, e);        &#125;        return false;    &#125;    /**     * 删除节点     *     * @param path 节点路径     * @return true成功 false失败     */    public boolean deleteNode(String path) &#123;        try &#123;            if (existsNode(path)) &#123;                zkClient.delete(path, -1);            &#125;            return true;        &#125; catch (Exception e) &#123;            LOGGER.error(&quot;delete for zk node error&quot;, e);        &#125;        return false;    &#125;    /**     * 获取子级节点     *     * @param path 节点路径     * @return 子级结果集合     */    public List&lt;String&gt; childrenNode(String path) &#123;        try &#123;            return zkClient.getChildren(path, true);        &#125; catch (Exception e) &#123;            LOGGER.error(&quot;obtain node child for error&quot;, e);        &#125;        return Collections.emptyList();    &#125;    /**     * 获取节点的数据     *     * @param path 节点路径     * @return 数据     */    public String dataGet(String path) &#123;        try &#123;            if (existsNode(path)) &#123;                byte[] data = zkClient.getData(path, true, new Stat());                return new String(data);            &#125;        &#125; catch (Exception e) &#123;            LOGGER.error(&quot;get zk node on data for error&quot;, e);        &#125;        return null;    &#125;    /**     * 判断节点是不是存在     *     * @param path zk节点     * @return true存在 false不存在     */    private boolean existsNode(String path) &#123;        try &#123;            return zkClient.exists(path, true) != null;        &#125; catch (Exception e) &#123;            LOGGER.error(&quot;judge zk node whether exists for error&quot;, e);        &#125;        return false;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 开源框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud笔记</title>
      <link href="/2023/06/07/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/SpringCloud%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/06/07/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/SpringCloud%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h1><p><strong>服务注册中心<code>eureka-server</code></strong></p><p>pom支持</p><pre><code class="xml"> &lt;dependency&gt;     &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;     &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>application.properties</p><pre><code class="properties">server.port=8080eureka.instance.hostname=localhost#是否注册到服务中心，本身就是注册中eureka.client.register-with-eureka=falseeureka.client.fetch-registry=false#服务中心的名字地址eureka.client.service-url.defaultZone=http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/spring.application.name=eureka-server</code></pre><p>启动类支持<code>@EnableEurekaServer</code></p><pre><code class="java">@SpringBootApplication@EnableEurekaServerpublic class SubkeyOneApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(SubkeyOneApplication.class, args);    &#125;&#125;</code></pre><p>访问<a href="http://localhost:8080即可看到所有已经注册的服务">http://localhost:8080即可看到所有已经注册的服务</a></p><hr><p><strong>服务注册</strong></p><p>pom支持</p><pre><code class="xml"> &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><p>application.properties</p><pre><code class="properties">server.port=8081spring.application.name=zuul-servereureka.client.service-url.defaultZone=http://localhost:8080/eureka</code></pre><p>启动类支持</p><pre><code class="java">@SpringBootApplication@EnableEurekaClient@EnableDiscoveryClient</code></pre><hr><p><strong>负载均衡：<code>Ribbon</code></strong></p><p>在使用<code>Ribbon</code>作为负载均衡的时候，需要手动注入一个<code>RestTemplate</code>的Bean到Ioc，并且为该Bean加入<code>@LoadBalanced</code>开启负载均衡，使其能够以查询到服务注册中心的服务。</p><p>例如：</p><pre><code class="java">@Bean@LoadBalancedpublic RestTemplate getRestTemplate()&#123;    return new RestTemplate();&#125;</code></pre><hr><p><strong>负载均衡：<code>Feign</code></strong></p><p>使用<code>Feign</code>作为负载均衡的时候，需要先在启动类使用<code>@EnableFeignClients</code>来开启，而后创建一个接口，使用<code>@FeignClient(value = &quot;DATA-SERVER&quot;)</code>标签来指定访问的服务</p><p>例如：</p><pre><code class="java">@FeignClient(value = &quot;DATA-SERVER&quot;)public interface IProductClientFeign &#123;    /**     * 请求数据     * @return 结果     */    @GetMapping(&quot;/product/all&quot;)    List&lt;Product&gt; allProduct();&#125;</code></pre><hr><p><strong>配置服务<code>ConfigServer</code></strong></p><p>pom配置服务包</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>配置文件<code>properties</code>，配置服务参数</p><pre><code class="properties">server.port=8030spring.application.name=config-servereureka.client.service-url.defaultZone=http://localhost:8080/eurekaspring.cloud.config.label=masterspring.cloud.config.server.git.uri=https://github.com/Huangjie-Github/spring-cloud-config-serverspring.cloud.config.server.git.search-paths=configspring.cloud.config.server.git.username=Huangjie-Githubspring.cloud.config.server.git.password=h19981228j</code></pre><p>在启动类上开启服务</p><pre><code class="java">@EnableEurekaClient@EnableConfigServer@EnableDiscoveryClient</code></pre><hr><p><strong>使用<code>ConfigServer</code></strong></p><p>pom引入服务使用包</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>配置文件中声明配置服务参数</p><p><strong>注意：</strong>在使用配置服务的时候，下列参数一定要新建一个bootstrap.properties&#x2F;bootstrap.yml的配置文件，因为bootstrap的配置文件会比application的配置文件先启动加载，需要先启动加载好配置服务才能进行本服务的相关数据注入</p><pre><code class="properties">#分支spring.cloud.config.label=master#启用的模式spring.cloud.config.profile=dev#是否发现启用spring.cloud.config.discovery.enabled=true#注册中心的名称spring.cloud.config.discovery.serviceId=CONFIG-SERVEReureka.client.service-url.defaultZone=http://localhost:8080/eureka</code></pre><p>配置之后，只需要在引用的类上使用<code>@RefreshScope</code>标签开启，需要引用的参数上使用<code>@Value</code>标签即可</p><hr><p><strong>消息总线bus：<code>RabbitMQ</code></strong></p><p>pom使用jar</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;   &lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt; </code></pre><p>配置文件修改</p><p>bootstrap.properties</p><pre><code class="properties">#与配置服务绑定spring.cloud.config.label=masterspring.cloud.config.profile=devspring.cloud.config.discovery.enabled=truespring.cloud.config.discovery.serviceId=CONFIG-SERVEReureka.client.service-url.defaultZone=http://localhost:8080/eureka#bus总线配置spring.cloud.bus.enabled=truespring.cloud.bus.trace.enabled=true#配置RabbitMQspring.rabbitmq.host=127.0.0.1spring.rabbitmq.port=5672spring.rabbitmq.username=guestspring.rabbitmq.password=guest</code></pre><p>application.properties</p><pre><code class="properties">server.port=8011spring.application.name=feign-server#路线访问允许/actuator/refreshmanagement.endpoints.web.exposure.include=*management.endpoints.web.cors.allowed-origins=*management.endpoints.web.cors.allowed-methods=*</code></pre><p>访问需要更新的微服务<a href="http://localhost:801/actuator/refresh">http://localhost:801/actuator/refresh</a></p><p>该访问不支持Get访问，只支持Post访问</p><pre><code class="java">public static void main(String[] args) &#123;        HashMap&lt;String,String&gt; headers =new HashMap&lt;&gt;();        headers.put(&quot;Content-Type&quot;, &quot;application/json; charset=utf-8&quot;);        System.out.println(&quot;因为要去git获取，还要刷新config-server, 会比较卡，所以一般会要好几秒才能完成，请耐心等待&quot;);         String result = HttpUtil.createPost(&quot;http://localhost:8012/actuator/bus-refresh&quot;).addHeaders(headers).execute().body();        System.out.println(&quot;result:&quot;+result);        System.out.println(&quot;refresh 完成&quot;);    &#125;</code></pre><hr><p><strong>断路器<code>Hystrix</code></strong></p><p>pom支持</p><pre><code class="xml">&lt;dependency&gt;     &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;     &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt;   </code></pre><p>原来使用Feign做负载均衡的连接接口类修改其</p><pre><code class="java">//原来的@FeignClient(value = &quot;DATA-SERVER&quot;)//修改之后的@FeignClient(value = &quot;DATA-SERVER&quot;,fallback = ProductClientFeignHystrixImpl.class)</code></pre><p><code>fallback</code>：回退，大概就是说，当指定的微服务不可用时，回退到指定类中的复写方法。因为指定的回退类是继承与当前的接口，那么必定需要继承当前的访问抽象方法。所以，在微服务不可用的时候，调用其复写的方法，做微服务不可用处理。</p><p>IProductClientFeign.class</p><pre><code class="java">@FeignClient(value = &quot;DATA-SERVER&quot;,fallback = ProductClientFeignHystrixImpl.class)public interface IProductClientFeign &#123;    /**     * 请求数据     * @return 结果     */    @GetMapping(&quot;/product/all&quot;)    List&lt;Product&gt; allProduct();&#125;</code></pre><p>ProductClientFeignHystrixImpl.class</p><pre><code class="java">@Componentpublic class ProductClientFeignHystrixImpl implements IProductClientFeign &#123;    @Override    public List&lt;Product&gt; allProduct() &#123;        ArrayList&lt;Product&gt; products = new ArrayList&lt;&gt;();        products.add(new Product(1,&quot;数据服务不可用&quot;,0));        return products;    &#125;&#125;</code></pre><p>配置完断路器之后，还需要去启动类中启用它<code>@EnableHystri</code>，以及去配置文件中开启相关服务操作<code>feign.hystrix.enabled=true</code></p><hr><p><strong>断路器监听<code>hystrix-dashboard</code></strong></p><p>pom支持</p><pre><code class="xml">&lt;!--        连接服务注册中心--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--        断路器监听--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--        断路器--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--        环节映射--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>启动类上开启断路器监听</p><p><code>@EnableHystrixDashboard</code>：开启断路监听</p><pre><code class="java">@SpringBootApplication@EnableHystrixDashboard@EnableEurekaClientpublic class HystrixMonitorServerApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(HystrixMonitorServerApplication.class, args);    &#125;&#125;</code></pre><p>application.properties</p><pre><code class="properties">server.port=8040spring.application.name=hystrix-monitor-servereureka.client.service-url.defaultZone=http://localhost:8080/eureka</code></pre><p>给共享信息让监听器监听的微服务使用<code>@EnableCircuitBreaker</code>开启分享</p><pre><code class="java">@SpringBootApplication@EnableEurekaClient@EnableFeignClients@EnableDiscoveryClient@EnableHystrix@EnableCircuitBreakerpublic class FeignServerApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(FeignServerApplication.class, args);    &#125;&#125;</code></pre><p><code>@SpringBootApplication</code>：SpeingBoot启动类<br><code>@EnableEurekaClient</code>：启用微服务注册连接，让注册中心发现，扫描该服务<br><code>@EnableFeignClients</code>：让注册中心发现这个Feign负载均衡的服务<br><code>@EnableDiscoveryClient</code>：<br><code>@EnableHystrix</code>：启用熔断<br><code>@EnableCircuitBreaker</code>：分享信息给熔断监听，本身必须要有熔断机制</p><p>访问地址</p><p><a href="http://localhost:8040/hystrix">http://localhost:8040/hystrix</a></p><p>监听地址</p><p><a href="http://localhost:8011/actuator/hystrix.stream">http://localhost:8011/actuator/hystrix.stream</a></p><hr><p>断路器聚合监听</p><p>pom支持</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-turbine&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>application.properties</p><pre><code class="properties">server.port=8050spring.application.name=hystrix-turbine-servereureka.client.service-url.defaultZone=http://localhost:8080/eurekaturbine.aggregator.cluster-config=default#配置Eureka中的serviceId列表，表明监控哪些服务turbine.app-config=feign-serverturbine.cluster-name-expression= new String(&quot;default&quot;)</code></pre><p>启动类开启</p><pre><code class="java">@SpringBootApplication@EnableTurbine@EnableEurekaClientpublic class HystrixTurbineServerApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(HystrixTurbineServerApplication.class, args);    &#125;&#125;</code></pre><p>使用上面的熔断监听服务去获得监听服务</p><p><a href="http://localhost:8040/hystrix%E3%80%81">http://localhost:8040/hystrix、</a></p><p>输入聚合监听的端口地址进行局和监听</p><p><a href="http://localhost:8050/turbine.stream">http://localhost:8050/turbine.stream</a></p><hr><p><strong>网关<code>zuul</code></strong></p><p>pom支持</p><pre><code class="xml">&lt;dependency&gt;     &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;     &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>application.properties</p><pre><code class="properties">server.port=8060spring.application.name=zuul-servereureka.client.service-url.defaultZone=http://localhost:8080/eureka#映射zuul.routes.api-a.path=/api-data/**zuul.routes.api-a.service-id=DATA-SERVERzuul.routes.api-b.path=/api-feign/**zuul.routes.api-b.service-id=FEIGN-SERVER</code></pre><p>启动类开启网关注册<code>@EnableZuulProxy</code></p><pre><code class="java">@SpringBootApplication@EnableEurekaClient@EnableDiscoveryClient@EnableZuulProxypublic class ZuulServerApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(ZuulServerApplication.class, args);    &#125;&#125;</code></pre><p>访问地址</p><p><a href="http://localhost:8060/api-feign/feign/all">http://localhost:8060/api-feign/feign/all</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 开源框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity整合</title>
      <link href="/2023/06/07/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/SpringSecurity%E6%95%B4%E5%90%88/"/>
      <url>/2023/06/07/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/SpringSecurity%E6%95%B4%E5%90%88/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-SpringSecurity初体验date-2022-10-13-10-09-19-248updated-2022-10-13-14-40-09-804url-x2F-archives-x2F-springsecurity-chu-ti-yancategories-SpringSecuritytags-SpringSecurity"><a href="#title-SpringSecurity初体验date-2022-10-13-10-09-19-248updated-2022-10-13-14-40-09-804url-x2F-archives-x2F-springsecurity-chu-ti-yancategories-SpringSecuritytags-SpringSecurity" class="headerlink" title="title: SpringSecurity初体验date: 2022-10-13 10:09:19.248updated: 2022-10-13 14:40:09.804url: &#x2F;archives&#x2F;springsecurity-chu-ti-yancategories:- SpringSecuritytags:- SpringSecurity"></a>title: SpringSecurity初体验<br>date: 2022-10-13 10:09:19.248<br>updated: 2022-10-13 14:40:09.804<br>url: &#x2F;archives&#x2F;springsecurity-chu-ti-yan<br>categories:<br>- SpringSecurity<br>tags:<br>- SpringSecurity</h2><p>首先引入pom依赖</p><pre><code class="xml">&lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>继承WebSecurityConfigurerAdapter复写如下方法，完成配置</p><pre><code class="java">/** * @author huangJie * @version 1.0v * @date 2022/10/12 10:33 */@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;    @Resource    private UserService userService;    @Resource    private SecurityExcludeUrlProperty securityExcludeUrlProperty;    /**     * 自定义的编码密码接口，这里直接返回的明码，demo不做加密编码处理     *     * @return 接口实现     */    @Bean    public PasswordEncoder passwordEncoder() &#123;        return new PasswordEncoder() &#123;            @Override            public String encode(CharSequence charSequence) &#123;                return (String) charSequence;            &#125;            @Override            public boolean matches(CharSequence charSequence, String s) &#123;                return charSequence.equals(s);            &#125;        &#125;;    &#125;    /**     * 配置HttpSecurity     *     * @param http HttpSecurity     * @throws Exception 产生异常     */    @Override    protected void configure(HttpSecurity http) throws Exception &#123;        http.authorizeRequests()                .antMatchers(securityExcludeUrlProperty.getUri()).permitAll()                .anyRequest().authenticated()                .and()                .addFilterBefore(new TokenFilter(userService), UsernamePasswordAuthenticationFilter.class)                .exceptionHandling()                .accessDeniedHandler(new CustomAccessDeniedHandler())                .authenticationEntryPoint(new CustomAuthenticationEntryPoint())                .and().sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).disable()                .formLogin().disable()                .logout().disable()                .csrf().disable();    &#125;    /**     * 用来配置自定义的鉴权操作     *     * @param auth 用来配置支持鉴权的构建器     * @throws Exception 产生异常     */    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;        super.configure(auth);        // auth.authenticationProvider(new AuthenticationProvider() &#123;        //     @Override        //     public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123;        //         return null;        //     &#125;        //        //     @Override        //     public boolean supports(Class&lt;?&gt; authentication) &#123;        //         return true;        //     &#125;        // &#125;);    &#125;&#125;</code></pre><p>自定义HttpSecurity之后的调用链路</p><blockquote><p>Security filter chain:<br>  WebAsyncManagerIntegrationFilter<br>  SecurityContextPersistenceFilter<br>  HeaderWriterFilter<br>  TokenFilter<br>  RequestCacheAwareFilter<br>  SecurityContextHolderAwareRequestFilter<br>  AnonymousAuthenticationFilter<br>  ExceptionTranslationFilter<br>  FilterSecurityInterceptor</p></blockquote><p>其中TokenFilter为自定义的Filter</p><pre><code class="java">/** * @author huangJie * @version 1.0v * @date 2022/10/12 11:00 */@Slf4jpublic class TokenFilter extends GenericFilterBean &#123;    private final UserService userService;    public TokenFilter(UserService userService) &#123;        this.userService = userService;    &#125;    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        HttpServletRequest request = (HttpServletRequest) servletRequest;        String authorization = request.getHeader(&quot;Authorization&quot;);        if (StringUtils.hasLength(authorization))&#123;            UserDetails userDetails = userService.loadUserByUsername(authorization);            SecurityContextHolder.getContext().setAuthentication(                    new UsernamePasswordAuthenticationToken(userDetails.getUsername(), userDetails.getPassword()));        &#125;        filterChain.doFilter(servletRequest, servletResponse);    &#125;&#125;</code></pre><p>对于用户信息获取需要实现<code>UserDetailsService</code>接口，这里并未对用户信息做复杂操作，只为过登录校验做了处理</p><pre><code class="java">/** * @author huangJie * @version 1.0v * @date 2022/10/12 14:02 */public interface UserService extends UserDetailsService &#123;&#125;/** * @author huangJie * @version 1.0v * @date 2022/10/12 14:02 */@Servicepublic class UserServiceImpl implements UserService &#123;    @Override    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;        UserEntity user = new UserEntity();        user.setUsername(username);        user.setPassword(username);        return user;    &#125;&#125;</code></pre><p>其中<code>UserEntity</code>也是实现自UserDetails类</p><pre><code class="java">/** * @author huangJie * @version 1.0v * @date 2022/10/12 10:44 */@Setterpublic class UserEntity implements UserDetails, Serializable &#123;    private static final long serialVersionUID = 3532830780866118325L;    private String username;    private String password;    private List&lt;String&gt; roles = new ArrayList&lt;String&gt;() &#123;        private static final long serialVersionUID = 8112282703158213813L;        &#123;            add(&quot;ADMIN&quot;);            add(&quot;USER&quot;);        &#125;    &#125;;    @Override    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;        List&lt;GrantedAuthority&gt; auth = new ArrayList&lt;&gt;();        for (String role : roles) &#123;            auth.add(new SimpleGrantedAuthority(role));        &#125;        return auth;    &#125;    @Override    public String getPassword() &#123;        return password;    &#125;    @Override    public String getUsername() &#123;        return username;    &#125;    @Override    public boolean isAccountNonExpired() &#123;        return true;    &#125;    @Override    public boolean isAccountNonLocked() &#123;        return true;    &#125;    @Override    public boolean isCredentialsNonExpired() &#123;        return true;    &#125;    @Override    public boolean isEnabled() &#123;        return true;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 开源框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring上下文ApplicationContext</title>
      <link href="/2023/06/07/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/Spring%E4%B8%8A%E4%B8%8B%E6%96%87ApplicationContext/"/>
      <url>/2023/06/07/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/Spring%E4%B8%8A%E4%B8%8B%E6%96%87ApplicationContext/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-在静态方法中引入bean"><a href="#Java-在静态方法中引入bean" class="headerlink" title="Java 在静态方法中引入bean"></a>Java 在静态方法中引入bean</h1><p>ApplicationContextAware: 相当于在ApplicationContext上下文初始化的时候，会触发的一个钩子，而要想触发就要加入到Bean容器中去进行管理</p><pre><code class="java">public class SpringContextUtils implements ApplicationContextAware &#123;    private static ApplicationContext applicationContext;    public static void setStatusApplicationContext(ApplicationContext applicationContext) &#123;        SpringContextUtils.applicationContext = applicationContext;    &#125;    @Override    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;        SpringContextUtils.setStatusApplicationContext(applicationContext);    &#125;    public static &lt;T&gt; T bean(Class&lt;T&gt; clazz) &#123;        return applicationContext.getBean(clazz);    &#125;&#125;</code></pre><p>bean注入</p><pre><code class="java">@Beanpublic SpringContextUtils springContextUtils()&#123;    return new SpringContextUtils();&#125;</code></pre><p>而后只需要在使用的时候使用bean方法，依据类型或者名称等等进行注入即可</p>]]></content>
      
      
      <categories>
          
          <category> 开源框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring的AOP自定义注解</title>
      <link href="/2023/06/07/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/Spring%E7%9A%84AOP%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
      <url>/2023/06/07/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/Spring%E7%9A%84AOP%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="自定义注解AOP"><a href="#自定义注解AOP" class="headerlink" title="自定义注解AOP"></a>自定义注解AOP</h1><p><strong>POM文件导入</strong></p><p>开启AOP操作</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p><strong>创建一个注解</strong></p><p>元注解</p><ul><li>@Documented：用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。它是一个标记注解，没有成员。</li><li>@Inherited：用于表示某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。</li><li>@Target：用于描述注解的范围，即注解在哪用。它说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）等。取值类型（ElementType）有以下几种：<ul><li>CONSTRUCTOR:用于描述构造器</li><li>FIELD:用于描述域即类成员变量</li><li>LOCAL_VARIABLE:用于描述局部变量</li><li>METHOD:用于描述方法</li><li>PACKAGE:用于描述包</li><li>PARAMETER:用于描述参数</li><li>TYPE:用于描述类、接口(包括注解类型) 或enum声明</li><li>TYPE_PARAMETER:1.8版本开始，描述类、接口或enum参数的声明</li><li>TYPE_USE:1.8版本开始，描述一种类、接口或enum的使用声明</li></ul></li><li>Retention：用于描述注解的生命周期，表示需要在什么级别保存该注解，即保留的时间长短。取值类型（RetentionPolicy）有以下几种：<ul><li>SOURCE:在源文件中有效（即源文件保留）</li><li>CLASS:在class文件中有效（即class保留）</li><li>RUNTIME:在运行时有效（即运行时保留）</li></ul></li></ul><pre><code class="java">@Documented@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface AllowToken &#123;&#125;</code></pre><p><strong>创建AOP切入实现类</strong></p><pre><code class="java">@Aspect@Componentpublic class TokenAspect &#123;    //设置切入点    @Pointcut(value = &quot;@annotation(cn.ajiehome.tools.annotations.AllowToken)&quot;)    private void pointCut()&#123;&#125;    @Before(value = &quot;pointCut()&amp;&amp;@annotation(allowToken)&quot;)    private void before(AllowToken allowToken)&#123;        //AOP前置通知 advice        //获取被注解方法的request        ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();        assert servletRequestAttributes != null;        HttpServletRequest request = servletRequestAttributes.getRequest();                String token = request.getHeader(&quot;token&quot;);        if (token==null)&#123;            throw new ApplicationException(CodeType.TOKEN_TIME_OUT);        &#125;        //解析token        DecodedJWT decode = JWT.decode(token);        //Jwt的头部，由于头部被Base64编码过了，所以需要base64逆解编码        String header = new String(Base64.getDecoder().decode(decode.getHeader()));        //Jwt的中间部分，理由同上头部        String payload = new String(Base64.getDecoder().decode(decode.getPayload()));        //解析头部        JSONObject userJson = JSONObject.parseObject(header);        String id = userJson.getString(&quot;id&quot;);        String userName = userJson.getString(&quot;userName&quot;);        //逆解匹配整个Token的编码以及密钥key        Algorithm algorithm = Algorithm.HMAC256(id);        try &#123;            //设置验证条件，这里设置了验证的密钥和编码以及验证的签发人            JWTVerifier jwtVerifier = JWT.require(algorithm).withIssuer(userName).build();            //验证是否匹配，如果Token不匹配或者超时，此处将抛出异常            DecodedJWT verify = jwtVerifier.verify(token);            //需要的信息获取从头部份获取和中间部分获取        &#125;catch (Exception e)&#123;            throw  new ApplicationException(CodeType.TOKEN_TIME_OUT);        &#125;    &#125;    @After(value = &quot;pointCut()&amp;&amp;@annotation(allowToken)&quot;)    private void after(AllowToken allowToken)&#123;        //AOP后置通知 advice    &#125;    @AfterReturning(value = &quot;pointCut()&amp;&amp; @annotation(allowToken)&quot;,returning = &quot;o&quot;)    private void alterReturn(AllowToken allowToken,Object o)&#123;        //AOP返回通知 advice    &#125;    @AfterThrowing(value = &quot;pointCut()&amp;&amp;@annotation(allowToken)&quot;)    private void alterError(AllowToken allowToken)&#123;        //AOP异常通知 advice    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 开源框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring静态方法中使用Bean</title>
      <link href="/2023/06/07/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/Spring%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8Bean/"/>
      <url>/2023/06/07/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/Spring%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8Bean/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-Java-在静态方法中引入beandate-2022-04-15-18-27-17-616updated-2022-10-13-15-03-27-631url-x2F-archives-x2F-java-zai-jing-tai-fang-fa-zhong-yin-ru-beancategories-SpringBoottags-SpringBoot"><a href="#title-Java-在静态方法中引入beandate-2022-04-15-18-27-17-616updated-2022-10-13-15-03-27-631url-x2F-archives-x2F-java-zai-jing-tai-fang-fa-zhong-yin-ru-beancategories-SpringBoottags-SpringBoot" class="headerlink" title="title: Java 在静态方法中引入beandate: 2022-04-15 18:27:17.616updated: 2022-10-13 15:03:27.631url: &#x2F;archives&#x2F;java-zai-jing-tai-fang-fa-zhong-yin-ru-beancategories:- SpringBoottags:- SpringBoot"></a>title: Java 在静态方法中引入bean<br>date: 2022-04-15 18:27:17.616<br>updated: 2022-10-13 15:03:27.631<br>url: &#x2F;archives&#x2F;java-zai-jing-tai-fang-fa-zhong-yin-ru-bean<br>categories:<br>- SpringBoot<br>tags:<br>- SpringBoot</h2><p>ApplicationContextAware: 相当于在ApplicationContext上下文初始化的时候，会触发的一个钩子，而要想触发就要加入到Bean容器中去进行管理</p><pre><code class="java">public class SpringContextUtils implements ApplicationContextAware &#123;    private static ApplicationContext applicationContext;    public static void setStatusApplicationContext(ApplicationContext applicationContext) &#123;        SpringContextUtils.applicationContext = applicationContext;    &#125;    @Override    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;        SpringContextUtils.setStatusApplicationContext(applicationContext);    &#125;    public static &lt;T&gt; T bean(Class&lt;T&gt; clazz) &#123;        return applicationContext.getBean(clazz);    &#125;&#125;</code></pre><p>bean注入</p><pre><code class="java">@Beanpublic SpringContextUtils springContextUtils()&#123;    return new SpringContextUtils();&#125;</code></pre><p>而后只需要在使用的时候使用bean方法，依据类型或者名称等等进行注入即可</p>]]></content>
      
      
      <categories>
          
          <category> 开源框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Centos7安装Wordpress</title>
      <link href="/2023/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Centos7%E5%AE%89%E8%A3%85Wordpress/"/>
      <url>/2023/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Centos7%E5%AE%89%E8%A3%85Wordpress/</url>
      
        <content type="html"><![CDATA[<h1 id="Centos7安装Wordpress以及环境"><a href="#Centos7安装Wordpress以及环境" class="headerlink" title="Centos7安装Wordpress以及环境"></a>Centos7安装Wordpress以及环境</h1><h2 id="一、安装MySQL57版本"><a href="#一、安装MySQL57版本" class="headerlink" title="一、安装MySQL57版本"></a>一、安装MySQL57版本</h2><p><strong>1、从MySQL官网下载YUM源的RPM安装包</strong></p><pre><code class="shell">wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm</code></pre><p><strong>2、从下载好的rpm包安装MYSQL</strong></p><pre><code class="shell">yum localinstall mysql57-community-release-el7-8.noarch.rpm</code></pre><p><strong>3、安装MySQL服务</strong></p><pre><code class="shell">yum install mysql-community-server</code></pre><p><strong>4、启动MySQL服务</strong></p><pre><code class="shell">systemctl start mysqld.service</code></pre><p><strong>5、设置开机自启并且刷新</strong></p><pre><code class="shell">systemctl enable mysqldsystemctl daemon-reload</code></pre><p><strong>6、修改默认初始化密码-&gt;由于密码策略所以只能设置较为复杂的密码</strong></p><pre><code class="shell">#临时密码在/var/log/mysqld.logalter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;ZhonHua@5000Nian&#39;;</code></pre><p><strong>7、查看MySQL的密码安全策略</strong></p><pre><code class="shell">show variables like &#39;validate_password%&#39;;</code></pre><p><img src="/./images/MYSQL%E5%AF%86%E7%A0%81%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5.PNG" alt="img"></p><p><strong>8、修改密码杂度为最低以及把密码长度改为自己想要的</strong></p><pre><code class="shell">set global validate_password_policy = LOW;set global validate_password_length = 6;</code></pre><p><img src="/./images/MySQL%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E7%AD%96%E7%95%A5.PNG" alt="img"></p><p><strong>9、修改为自己想要的密码</strong></p><pre><code class="shell">alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;123456&#39;;</code></pre><p><strong>10、创建wordpress数据库</strong></p><pre><code class="shell">create database wordpress;</code></pre><p><strong>11、允许远程登陆然后刷新</strong></p><pre><code class="shell">grant all on *.* to root@&#39;%&#39; identified by &#39;password&#39; with grant option;flush privileges;</code></pre><p><strong>12、重启MySQL服务</strong></p><pre><code class="shell">systemctl restart mysqld.service</code></pre><p><strong>13、密码忘记或者策略失败</strong></p><pre><code class="shell">#关闭密码验证策略，url：vi /root/my.cnfskip-grant-tables#修改mysql.user表的密码update mysql.user set authentication_string=password(&#39;新密码&#39;) where user=&#39;root&#39; ;#刷新flush privileges ;#然后删除skip-grant-tables之后重启MySQL服务</code></pre><h2 id="二、安装apache-gt-httpd"><a href="#二、安装apache-gt-httpd" class="headerlink" title="二、安装apache-&gt;httpd"></a>二、安装apache-&gt;httpd</h2><p><strong>1、安装httpd</strong></p><pre><code class="shell">yum install httpd</code></pre><p><strong>2、启动httpd服务</strong></p><pre><code class="shell">systemctl start httpd.service</code></pre><p><strong>3、设置成开机自启并且刷新</strong></p><pre><code class="shell">systemctl enable httpd.servicesystemctl daemon-reload</code></pre><h2 id="三、安装php-gt-及相关驱动"><a href="#三、安装php-gt-及相关驱动" class="headerlink" title="三、安装php-&gt;及相关驱动"></a>三、安装php-&gt;及相关驱动</h2><p><strong>1、安装php、php-fpm、php-mysql</strong></p><pre><code class="shell">yum install php php-fpm php-mysql</code></pre><p><strong>2、启动php-fpm服务</strong></p><pre><code class="shell">systemctl start php-fpm.service</code></pre><p><strong>3、设置成开机自启并且刷新</strong></p><pre><code class="shell">systemctl enable php-fpm.servicesystemctl daemon-reload</code></pre><h2 id="四、查看三个服务的运行状态"><a href="#四、查看三个服务的运行状态" class="headerlink" title="四、查看三个服务的运行状态"></a>四、查看三个服务的运行状态</h2><p><strong>httpd监听80端口，mysql监听3306端口，php-fpm监听9000端口</strong></p><pre><code class="shell">netstat -tunlp</code></pre><h2 id="五、安装wordpress官网tar-gz安装包"><a href="#五、安装wordpress官网tar-gz安装包" class="headerlink" title="五、安装wordpress官网tar.gz安装包"></a>五、安装wordpress官网tar.gz安装包</h2><p><strong>2、用wget获取wordpress安装包</strong></p><pre><code class="shell">wget https://ww.wp.xz.cn/wordpress-4.5.20.tar.gz</code></pre><p><strong>3、解压安装包到&#x2F;var&#x2F;www路径下</strong></p><pre><code class="shell">tar -zxf wordpress-4.5.20.tar.gz -C /var/www</code></pre><p><strong>4、修改httpd的配置文件把默认的映射路径改为&#x2F;var&#x2F;www&#x2F;wordpress</strong>  </p><pre><code class="shell">vi  /etc/httpd/conf/httpd.conf# DocumentRoot的值**5、保存修改文件退出后重新启动httpd服务**```shellsystemctl restart httpd.service</code></pre><p><strong>6、把wordpress目录赋予apache所有权限</strong></p><pre><code class="shell">chown -R apache:apache /var/www/wordpress</code></pre><h2 id="六、用浏览器启动绑定服务器的域名或者服务器的IP然后就可以开始配置相关的数据"><a href="#六、用浏览器启动绑定服务器的域名或者服务器的IP然后就可以开始配置相关的数据" class="headerlink" title="六、用浏览器启动绑定服务器的域名或者服务器的IP然后就可以开始配置相关的数据"></a>六、用浏览器启动绑定服务器的域名或者服务器的IP然后就可以开始配置相关的数据</h2>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Centos7常用命令</title>
      <link href="/2023/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Centos7%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Centos7%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Centos7常用命令"><a href="#Centos7常用命令" class="headerlink" title="Centos7常用命令"></a>Centos7常用命令</h1><p><strong>防火墙相关命令</strong></p><ul><li><p>防火墙的开启、关闭、重启、与状态</p><pre><code class="shell"> #开启 systemctl start   firewalld.service #关闭 systemctl stop    firewalld.service #重启 systemctl restart firewalld.service #状态 systemctl status  firewalld.service #设置开机自启 systemctl enable  firewalld.service #关闭开机自启 systemctl disable firewalld.service  #指定IP放行指定端口 firewall-cmd --permanent --add-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;192.168.142.166&quot; port protocol=&quot;tcp&quot; port=&quot;5432&quot; accept&quot;</code></pre></li><li><p>查看所有公开项目</p><pre><code class="shell"> #查看所有公开项 firewall-cmd --list-all #查看端口是否放行 firewall-cmd --zone=public --query-port=80/tcp</code></pre></li><li><p>防火墙放行端口或服务</p><pre><code class="shell"> #添加放行端口 firewall-cmd --zone=public --add-port=80/tcp --permanent #重新加载所有的设置项 firewall-cmd --reload</code></pre><pre><code class="shell">  #添加放行服务  firewall-cmd --zone=public --add-service=http --permanent  firewall-cmd --reload</code></pre></li><li><p>防火墙移除放行端口或服务</p><pre><code class="shell"> #移除已经放行的端口 firewall-cmd --zone=public --remove-port=80/tcp firewall-cmd --reload</code></pre><pre><code class="shell">  #移除已经放行服务  firewall-cmd --zone=public --remove-service=http  firewall-cmd --reload</code></pre></li></ul><p><strong>端口操作</strong></p><ul><li><p>端口占用查询</p><pre><code class="shell"> netstat -tunlp | grep &#39;port&#39; ---------------------------------------------------------------------------------- -t (tcp) 仅显示tcp相关选项 -u (udp) 仅显示udp相关选项 -n 拒绝显示别名，能显示数字的全部转化为数字 -l 仅列出在Listen(监听)的服务状态 -p 显示建立相关链接的程序名</code></pre><pre><code class="shell"> lsof -i:&#39;port&#39;</code></pre></li><li><p>端口终结</p><pre><code class="shell"> kill -9 &#39;pid&#39;</code></pre></li></ul><p><strong>服务操作</strong></p><ul><li><p>服务状态查询</p><pre><code class="shell">  systemctl status &#39;serverName&#39;</code></pre></li><li><p>服务开启</p><pre><code class="shell">  sysyemctl start &#39;serverName&#39;</code></pre></li><li><p>服务关闭</p><pre><code class="shell"> systemctl stop &#39;serverName&#39;</code></pre></li><li><p>服务自启</p><pre><code class="shell">  systemctl enable &#39;serverName&#39;</code></pre></li><li><p>关闭服务自启</p><pre><code class="shell"> systemctl disable &#39;serverName&#39;</code></pre></li></ul><p><strong>用户和组</strong></p><ul><li><p>用户和组</p><pre><code class="shell">  #添加用户  adduser &#39;userName&#39;</code></pre><pre><code class="shell">#新建工作组groupadd &#39;groupName&#39;</code></pre><pre><code class="shell">#添加用户，并且把把用户添加到指定名称的组useradd -g &#39;groupName&#39; &#39;userName&#39;</code></pre><pre><code class="shell">#给已有用户添加到工作组usermod -G &#39;groupName&#39; &#39;userName&#39;gpasswd -a &#39;userName&#39; &#39;groupName&#39;</code></pre><pre><code class="shell">#临时锁定用户的密码，使账户失效passwd &#39;userName&#39; -l#把临时锁定密码的用户开发，使账户重新有效passwd &#39;userName&#39; -u</code></pre><pre><code class="shell">#永久删除用户userdel &#39;userName&#39;#永久删除组groupdel &#39;groupName&#39;#同时删除用户和组usermod -G &#39;userName&#39; &#39;groupName&#39;#从指定的组中删除指定的用户gpassed -d &#39;userName&#39; &#39;groupName&#39;</code></pre><pre><code class="shell">#显示用户信息id &#39;userName&#39;#将用户添加到指定组usermod -G &#39;groupName&#39; &#39;userName&#39;#修改用户userName1的名称为userName2usermod -l &#39;userName2&#39; &#39;userName1&#39;#锁定账户usermod -L &#39;userName&#39;#解除用户锁定usermod -U &#39;userName&#39;</code></pre></li></ul><hr><p><strong>持续更新中…</strong></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Centos创建虚拟内存</title>
      <link href="/2023/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Centos%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
      <url>/2023/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Centos%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux创建虚拟内存"><a href="#Linux创建虚拟内存" class="headerlink" title="Linux创建虚拟内存"></a>Linux创建虚拟内存</h1><ol><li>创建swap文件夹，一般在根目录就好，swap通常代表虚拟内存</li><li>创建swapfile文件，swapfile为伪装成内存的文件<pre><code class="shell"> dd if=/dev/zero of=/swap/swapfile bs=1G count=4096</code></pre></li><li>将swapfile文件设置为swap分区文件<pre><code class="shell"> mkswap /swap/swapfile</code></pre></li><li>激活swap区，并立即启用交换区文件<pre><code class="shell"> swapon /swap/swapfile</code></pre></li><li>设置开机自启需要在<code>/etc/fstab</code>文件的末尾添加一行命令<pre><code class="shell">/swap/swapfile swap swap defaults 0 0</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Centos和Apache</title>
      <link href="/2023/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Centos%E5%92%8CApache/"/>
      <url>/2023/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Centos%E5%92%8CApache/</url>
      
        <content type="html"><![CDATA[<h1 id="Centos与Apache"><a href="#Centos与Apache" class="headerlink" title="Centos与Apache"></a>Centos与Apache</h1><p>Apache<br>在Apache的安装目录，默认：<code>/etc/httpd</code>下有若干文件夹，<code>conf.d</code>文件夹是用来存储各个模块的配置文件，<code>conf.module.d</code>是用来给各个模块做映入的，也就是很多模块的引入都在这里面，<code>conf</code>文件夹主要是主配置文件的目录，<code>logs</code>文件夹打印日志的存储地，<code>moduls</code>是各个模块的位置</p><h2 id="例如：httpd-conf：这个文件是apache的主配置文件，其他的conf-d和conf-module-d内的配置文件夹能够生效也是因为在这里面引入了两个文件夹下的所有文件，如shell-引入了conf-moudles-d下的所有配置文件，也就是所有需要的模块-Include-conf-modules-d-conf-引入了conf-d下的所有配置文件，也就是每个模块服务需要做的详细配置-IncludeOptional-conf-d-conf-gt-在我的主配置文件里面还有一个功能，那就是多域名的配置，这个的主要作用是，针对不同域名的访问，映射到不同的访问文件夹，具体的映射由vhost-map文件配置shell-RewriteEngine-on-RewriteMap-lowercase-int-tolower-RewriteMap-vhost-txt-var-www-vhost-map-RewriteCond-lowercase-SERVER-NAME-RewriteCond-vhost-1-RewriteRule-1-1"><a href="#例如：httpd-conf：这个文件是apache的主配置文件，其他的conf-d和conf-module-d内的配置文件夹能够生效也是因为在这里面引入了两个文件夹下的所有文件，如shell-引入了conf-moudles-d下的所有配置文件，也就是所有需要的模块-Include-conf-modules-d-conf-引入了conf-d下的所有配置文件，也就是每个模块服务需要做的详细配置-IncludeOptional-conf-d-conf-gt-在我的主配置文件里面还有一个功能，那就是多域名的配置，这个的主要作用是，针对不同域名的访问，映射到不同的访问文件夹，具体的映射由vhost-map文件配置shell-RewriteEngine-on-RewriteMap-lowercase-int-tolower-RewriteMap-vhost-txt-var-www-vhost-map-RewriteCond-lowercase-SERVER-NAME-RewriteCond-vhost-1-RewriteRule-1-1" class="headerlink" title="例如：httpd.conf：这个文件是apache的主配置文件，其他的conf.d和conf.module.d内的配置文件夹能够生效也是因为在这里面引入了两个文件夹下的所有文件，如shell #引入了conf.moudles.d下的所有配置文件，也就是所有需要的模块 Include conf.modules.d/*.conf #引入了conf.d下的所有配置文件，也就是每个模块服务需要做的详细配置 IncludeOptional conf.d/*.conf &gt;在我的主配置文件里面还有一个功能，那就是多域名的配置，这个的主要作用是，针对不同域名的访问，映射到不同的访问文件夹，具体的映射由vhost.map文件配置shell RewriteEngine on RewriteMap lowercase int:tolower RewriteMap vhost txt:/var/www/vhost.map RewriteCond ${lowercase:%{SERVER_NAME}} ^(.+)$ RewriteCond ${vhost:%1} ^(/.*)$ RewriteRule ^/(.*)$ %1/$1 "></a>例如：<code>httpd.conf</code>：这个文件是apache的主配置文件，其他的<code>conf.d</code>和<code>conf.module.d</code>内的配置文件夹能够生效也是因为在这里面引入了两个文件夹下的所有文件，如<br><code>shell #引入了conf.moudles.d下的所有配置文件，也就是所有需要的模块 Include conf.modules.d/*.conf #引入了conf.d下的所有配置文件，也就是每个模块服务需要做的详细配置 IncludeOptional conf.d/*.conf </code><br>&gt;在我的主配置文件里面还有一个功能，那就是多域名的配置，这个的主要作用是，针对不同域名的访问，映射到不同的访问文件夹，具体的映射由<code>vhost.map</code>文件配置<br><code>shell RewriteEngine on RewriteMap lowercase int:tolower RewriteMap vhost txt:/var/www/vhost.map RewriteCond $&#123;lowercase:%&#123;SERVER_NAME&#125;&#125; ^(.+)$ RewriteCond $&#123;vhost:%1&#125; ^(/.*)$ RewriteRule ^/(.*)$ %1/$1 </code></h2><blockquote><p>在开启了SSL服务之后，存在一个问题，由于我的域名证书是单域名证书，所以我只能够给特定的域名SSL授权，所以我配置了一个SSL的但域名拦截重定向，这里的意思是只拦截<code>ajiehome.cn</code>和<code>www.ajiehome.cn</code>两个服务请求开头的所有服务，并且转到<code>https</code>服务</p></blockquote><pre><code class="shell">RewriteEngine OnRewriteCond %&#123;SERVER_PORT&#125; 80RewriteCond %&#123;HTTP_HOST&#125; ^ajiehome.cn [NC,OR]RewriteCond %&#123;HTTP_HOST&#125; ^www.ajiehome.cn [NC]RewriteRule ^(.*)$ https://%&#123;HTTP_HOST&#125;/$1 [R,L]</code></pre><hr><blockquote><p>如果用下面这个进行拦截重定向的话，会造成所有二级子域名全部转到https，甚至由于正则匹配写的不当会全部重定向到主服务之下，这里的意思是，所有不是443端口的服务请求，全部重定向https下去，<br><code>SERVER_NAME</code>：指的是服务，也就是域名部分<br><code>REQUEST_URI</code>：指的是请求的地址，也就是域名的后半部分<br><code>HTTP_HOST</code>：</p></blockquote><pre><code class="shell">RewriteEngine OnRewriteCond %&#123;SERVER_PORT&#125; !^443 \$RewriteRule ^(.*)? \$ https://%&#123;SERVER_NAME&#125;%&#123;REQUEST_URI&#125; [L,R]</code></pre><hr><p>例如：<code>conf.module.d</code>下的<code>00-ssl.cof</code>文件</p><blockquote><p><code>00-ss.conf</code>文件，里面有一个<code>mod_ssl</code>模块的引用，这个文件夹里的模块主要就是给<code>ssl</code>服务使用的模块，如：</p></blockquote><pre><code class="shell">LoadModule ssl_module modules/mod_ssl.so</code></pre>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Centos安装FTP</title>
      <link href="/2023/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Centos%E5%AE%89%E8%A3%85FTP/"/>
      <url>/2023/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Centos%E5%AE%89%E8%A3%85FTP/</url>
      
        <content type="html"><![CDATA[<h1 id="Centos安装FTP-gt-简单安装"><a href="#Centos安装FTP-gt-简单安装" class="headerlink" title="Centos安装FTP-&gt;简单安装"></a>Centos安装FTP-&gt;简单安装</h1><p><strong>1、查看是否安装了FTP</strong></p><pre><code class="shell">rpm -qa | grep vsftpd</code></pre><p><strong>2、没有安装-&gt;安装vsftp</strong></p><pre><code class="shell">yum -y install vsftpd</code></pre><p><strong>3、添加FTP用户并修改密码</strong></p><pre><code class="shell">useradd ftpLogin -d /home/ftpLoginpasswd ftpLogin</code></pre><p><strong>4、修改vsftpd.conf配置文件</strong></p><pre><code class="shell">vi /etc/vsftpd/vsftpd.conf#把允许匿名登陆改为不允许anonymous_enable=YES -&gt;  anonymous_enable=NO#在最后一行加上默认的加载目录-&gt;也就是FTP目录local_root=/home/ftpLogin/</code></pre><p><strong>5、修改文件夹的用户权限</strong></p><pre><code class="shell">chmod -R 777 /home/ftpLogin</code></pre><p><strong>6、查看服务是否运行</strong></p><pre><code class="shell">#active为绿色则是运行状态 如何非运行的话就重新启动一下服务#重新启动systemctl restart vsftpd#启动服务systemctl start vsftpd#查看服务状态systemctl status vsftpd#设置自动启动systemctl enable vsftpdyum -y install ftp</code></pre><p><strong>7、安装FTP测试</strong></p><pre><code class="shell">#我的已经安装过了就不再测试yum -y install ftp#使用anonymous登陆 可以无密码登陆ftp localhost</code></pre><p><strong>8、关掉防火墙-&gt;放行20&amp;21端口 让其他设备也可访问（也可以设置防火墙规则，放行端口组）</strong></p><pre><code class="shell">#关掉防火墙systemctl stop firewalld.service#为了防止防火墙自启，设置的永久关闭systemctl disable firewalld.service</code></pre>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Centos安装Java</title>
      <link href="/2023/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Centos%E5%AE%89%E8%A3%85Java/"/>
      <url>/2023/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Centos%E5%AE%89%E8%A3%85Java/</url>
      
        <content type="html"><![CDATA[<h1 id="Centos使用yum安装java"><a href="#Centos使用yum安装java" class="headerlink" title="Centos使用yum安装java"></a>Centos使用yum安装java</h1><p><strong>首先查询系统是否自带jdk</strong></p><pre><code class="shell">rpm -qa | grep javarpm -qa | grep jdkrpm -qa | grep gcj</code></pre><p><strong>如果有就卸载对应的</strong></p><pre><code class="shell">rpm -qa | grep java | xargs rpm -e --nodeps</code></pre><p><strong>列出所有可安装的rpm包</strong></p><pre><code class="shell">yum list java-1.8*</code></pre><p><strong>安装java</strong></p><pre><code class="shell">yum install java-1.8.0-openjdk* -y</code></pre><p><strong>校验版本</strong></p><pre><code class="shell">java -version</code></pre>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Centos安装MySQL</title>
      <link href="/2023/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Centos%E5%AE%89%E8%A3%85MySQL/"/>
      <url>/2023/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Centos%E5%AE%89%E8%A3%85MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="Centos安装MySQL"><a href="#Centos安装MySQL" class="headerlink" title="Centos安装MySQL"></a>Centos安装MySQL</h1><h4 id="1、首先更新yum命令"><a href="#1、首先更新yum命令" class="headerlink" title="1、首先更新yum命令"></a>1、首先更新yum命令</h4><pre><code class="shell">yum update -y</code></pre><h4 id="3、下载MySQL的npm源"><a href="#3、下载MySQL的npm源" class="headerlink" title="3、下载MySQL的npm源"></a>3、下载MySQL的npm源</h4><pre><code class="shell">wget https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm</code></pre><h4 id="4、添加MySQL的npm源"><a href="#4、添加MySQL的npm源" class="headerlink" title="4、添加MySQL的npm源"></a>4、添加MySQL的npm源</h4><pre><code class="shell">yum localinstall mysql80-community-release-el7-3.noarch.rpm</code></pre><h4 id="5、查看当前的MySQL版本"><a href="#5、查看当前的MySQL版本" class="headerlink" title="5、查看当前的MySQL版本"></a>5、查看当前的MySQL版本</h4><pre><code class="shell">yum repolist enabled | grep &quot;mysql.*-community.*&quot;</code></pre><h4 id="6、查看所有MySQL可用版本"><a href="#6、查看所有MySQL可用版本" class="headerlink" title="6、查看所有MySQL可用版本"></a>6、查看所有MySQL可用版本</h4><pre><code class="shell">yum repolist all | grep mysql</code></pre><h4 id="7、关闭-x2F-禁用8-0的MySQL版本并且启用5-7的版本"><a href="#7、关闭-x2F-禁用8-0的MySQL版本并且启用5-7的版本" class="headerlink" title="7、关闭&#x2F;禁用8.0的MySQL版本并且启用5.7的版本"></a>7、关闭&#x2F;禁用8.0的MySQL版本并且启用5.7的版本</h4><pre><code class="shell">yum-config-manager --disable mysql80-communityyum-config-manager --enable mysql57-community</code></pre><h4 id="8、再次查看当前版本（正则匹配）"><a href="#8、再次查看当前版本（正则匹配）" class="headerlink" title="8、再次查看当前版本（正则匹配）"></a>8、再次查看当前版本（正则匹配）</h4><pre><code class="shell">yum repolist enabled | grep mysql</code></pre><h4 id="9、安装MySQL服务"><a href="#9、安装MySQL服务" class="headerlink" title="9、安装MySQL服务"></a>9、安装MySQL服务</h4><pre><code class="shell">yum install -y mysql-community-server</code></pre><h4 id="10、启用MySQL服务"><a href="#10、启用MySQL服务" class="headerlink" title="10、启用MySQL服务"></a>10、启用MySQL服务</h4><pre><code class="shell">systemctl start mysqld</code></pre><h4 id="11、查看临时默认密码，且修改密码"><a href="#11、查看临时默认密码，且修改密码" class="headerlink" title="11、查看临时默认密码，且修改密码"></a>11、查看临时默认密码，且修改密码</h4><pre><code class="shell">cat /var/log/mysqld.log# 由于密码策略所以只能设置较为复杂的密码alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;ZhonHua@5000Nian&#39;;</code></pre><h4 id="12、查看MySQL的密码安全策略"><a href="#12、查看MySQL的密码安全策略" class="headerlink" title="12、查看MySQL的密码安全策略"></a>12、查看MySQL的密码安全策略</h4><pre><code class="shell">show variables like &#39;validate_password%&#39;;</code></pre><h4 id="13、修改密码杂度为最低以及把密码长度改为自己想要的"><a href="#13、修改密码杂度为最低以及把密码长度改为自己想要的" class="headerlink" title="13、修改密码杂度为最低以及把密码长度改为自己想要的"></a>13、修改密码杂度为最低以及把密码长度改为自己想要的</h4><pre><code class="shell">set global validate_password_policy = LOW;set global validate_password_length = 6;</code></pre><h4 id="14、修改密码为自己想要的"><a href="#14、修改密码为自己想要的" class="headerlink" title="14、修改密码为自己想要的"></a>14、修改密码为自己想要的</h4><pre><code class="shell">alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;123456&#39;;</code></pre><h4 id="15、允许远程登陆然后刷新"><a href="#15、允许远程登陆然后刷新" class="headerlink" title="15、允许远程登陆然后刷新"></a>15、允许远程登陆然后刷新</h4><pre><code class="shell"># 允许登录grant all on *.* to root@&#39;%&#39; identified by &#39;you new password&#39; with grant option;# 刷新flush privileges;</code></pre><p>you new password：设置的新密码</p><h4 id="16、重启MySQL服务"><a href="#16、重启MySQL服务" class="headerlink" title="16、重启MySQL服务"></a>16、重启MySQL服务</h4><pre><code class="shell">systemctl restart mysqld.service</code></pre><hr><p><a href="https://dev.mysql.com/doc/mysql-yum-repo-quick-guide/en/">详情参照官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Centos安装RabbitMQ</title>
      <link href="/2023/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Centos%E5%AE%89%E8%A3%85RabbitMQ/"/>
      <url>/2023/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Centos%E5%AE%89%E8%A3%85RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="Centos安装RabbitMQ"><a href="#Centos安装RabbitMQ" class="headerlink" title="Centos安装RabbitMQ"></a>Centos安装RabbitMQ</h1><h2 id="安装Erlang环境"><a href="#安装Erlang环境" class="headerlink" title="安装Erlang环境"></a>安装Erlang环境</h2><pre><code class="shell"># 1、安装依赖项yum install -y epel-release# 2、添加存储库条目wget https://packages.erlang-solutions.com/erlang-solutions-1.0-1.noarch.rpmrpm -Uvh erlang-solutions-1.0-1.noarch.rpm# 3、安装yum install -y erlang# 4、验证是否安装成功erl -version</code></pre><h2 id="rabbitmq的命令"><a href="#rabbitmq的命令" class="headerlink" title="rabbitmq的命令"></a>rabbitmq的命令</h2><pre><code class="shell"># 开启web管理界面rabbitmq-plugins enable rabbitmq_management# 添加用户rabbitmqctl add_user admin admin# 设置用户对 &#39;/ 的权限rabbitmqctl set_permissions -p &quot;/&quot; &quot;admin&quot; &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;# 设置用户角色rabbitmqctl set_user_tags admin administrator</code></pre>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Centos安装V2ray和Acmesh</title>
      <link href="/2023/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Centos%E5%AE%89%E8%A3%85V2ray%E5%92%8CAcmesh/"/>
      <url>/2023/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Centos%E5%AE%89%E8%A3%85V2ray%E5%92%8CAcmesh/</url>
      
        <content type="html"><![CDATA[<p>acme.sh作为自动签发ssl证书，为域名提供https的服务<br>v2ray作为代理使用<br>acme.sh要做到自动签发就需要在域名服务商哪授权token，用来acme.sh在验证域名所有权的时候使用，所以我们使用阿里云的平台，授权一个能够访问验证域名权限的子用户，并且创建一个Secret</p><p>在CentOS中创建Secret的临时key和Secret</p><pre><code class="shell">export Ali_Key=&quot;&quot;export Ali_Secret=&quot;&quot;</code></pre><p>安装acme.sh,会在执行该命令的用户目录下生成一个.acme.sh目录，目录为隐藏目录，可以用ls -a查看</p><pre><code class="shell">curl  https://get.acme.sh | sh</code></pre><p>为指定的域名请求证书</p><pre><code class="shell">/root/.acme.sh/acme.sh   --issue   --dns dns_ali   -d ajiehome.online  -d www.ajiehome.online# 或/root/.acme.sh/acme.sh   --issue   --dns dns_ali   -d v.ajiehome.online</code></pre><p>将生成的域名ssl密钥文件拷贝到指定的目录</p><pre><code class="shell">/root/.acme.sh/acme.sh --install-cert -d ajiehome.online  \--key-file       /etc/nginx/ssl/ajiehome.online/ajiehome.online.key  \--fullchain-file /etc/nginx/ssl/ajiehome.online/ajiehome.online.cert \--reloadcmd     &quot;service nginx force-reload&quot;</code></pre><p>然后就是nginx的配置项</p><pre><code class="conf">server &#123;        listen  80;        listen [::]:80;        server_name ajiehome.online;        root /usr/share/nginx/ajiehome.online;        index index.html index.htm;        rewrite ^(.*)$ https://$&#123;server_name&#125;$1 permanent;        location / &#123;        &#125;&#125;server &#123;        listen 443 ssl;        listen [::]:443 ssl;        server_name ajiehome.online;        root /usr/share/nginx/ajiehome.online;        index index.html inex.htm;        location / &#123;                proxy_pass http://127.0.0.1:8090;        &#125;        ssl_certificate /etc/nginx/ssl/ajiehome.online/ajiehome.online.cert;        ssl_certificate_key /etc/nginx/ssl/ajiehome.online/ajiehome.online.key;        ssl_session_timeout 1d;        ssl_session_cache shared:MozSSL:10m;        ssl_session_tickets off;        ssl_protocols         TLSv1.2 TLSv1.3;        ssl_ciphers           ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;        ssl_prefer_server_ciphers off;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Centos定时任务Crontabs</title>
      <link href="/2023/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Centos%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1Crontabs/"/>
      <url>/2023/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Centos%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1Crontabs/</url>
      
        <content type="html"><![CDATA[<h1 id="crontabs-定时执行执行sh"><a href="#crontabs-定时执行执行sh" class="headerlink" title="crontabs-定时执行执行sh"></a>crontabs-定时执行执行sh</h1><p>首先安装crontabs工具</p><pre><code class="shell">yum install crontabs</code></pre><p>安装完之后，系统默认安装了<code>crond</code>服务，<code>crond</code>默认是自启状态</p><p><code>crond</code>的执行方式为每一分钟扫描本地是否有需要执行的事务</p><p><code>crontab</code> 命令。该命令和 at 命令类似，也是通过 <code>/etc/cron.allow </code>和 <code>/etc/cron.deny</code> 文件来限制某些用户是否可以使用 crontab 命令的。</p><table><thead><tr><th>功能</th><th>选项</th></tr></thead><tbody><tr><td>-u user</td><td>用来选择某个用户的crontab服务，如-u demo，则运行demo用户的crontab服务，一般默认root用户</td></tr><tr><td>-e</td><td>编辑某个用户的crontab文件内容，如果不指定用户，则默认编辑当前用户的crontab文件</td></tr><tr><td>-l</td><td>显示某个用户的crontab文件内容，如果不指定用户，则默认编辑当前用户的crontab文件</td></tr><tr><td>-r</td><td>从&#x2F;var&#x2F;spool&#x2F;cron中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件</td></tr><tr><td>-i</td><td>删除用户的crontab文件是给予提示</td></tr></tbody></table><p>例如：</p><pre><code class="shell">crontab -e# 进入crontab文件显示当前用户的所有内容# 如下所示# * * * * * /root/test.sh &gt;&gt; /root/log.log</code></pre><p>crontab的定时执行任务是通过<code>*</code>来进行确认时间的</p><table><thead><tr><th>项目</th><th>含义</th><th>范围</th></tr></thead><tbody><tr><td>第一个<code>*</code></td><td>一小时当中的第几分钟（minute）</td><td>0~59</td></tr><tr><td>第二个<code>*</code></td><td>一天当中的第几小时（hour）</td><td>0~23</td></tr><tr><td>第三个<code>*</code></td><td>一个月当中的第几天（day）</td><td>1~31</td></tr><tr><td>第四个<code>*</code></td><td>一年当中的第几个月（month）</td><td>1~12</td></tr><tr><td>第五个<code>*</code></td><td>一周当中的星期几（week）</td><td>0~7（0和7都代表星期日）</td></tr></tbody></table><p>在时间表示中还有一些符号含有特殊含义</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>表任何时间。比如第一个”*”就代表一小时中<br />每分钟都执行一次的意思。</td></tr><tr><td>,</td><td>代表不连续的时间。比如”0 8，12，16***”命令就代表在每<br />天的8点0分、12点0分、16点0分都执行一次命令</td></tr><tr><td>-</td><td>代表连续的时间范围。比如”0 5 ** 1-6”命令<br />代表在周一到周六的凌晨5点0分执行命令。</td></tr><tr><td>&#x2F;</td><td>代表每隔多久执行一次。比如”<em>&#x2F;10</em>***命令”<br />代表每隔 10 分钟就执行一次命令。</td></tr></tbody></table><p>例如：</p><pre><code class="shell"># 每五分钟执行一次*/5 * * * * /root/test.sh &gt;&gt; /root/log.log# 每一分钟执行一次* * * * * /root/test.sh &gt;&gt; /root/log.log# 没五分钟往log里面写入11*/5 * * * * /bin/echo &quot;11&quot; &gt;&gt; /root/log.log</code></pre><table><thead><tr><th>时间</th><th>含义</th></tr></thead><tbody><tr><td><code>45 22 * * *</code></td><td>在 22 点 45 分执行命令</td></tr><tr><td><code>0 17 * * 1</code></td><td>在每周一的 17 点 0 分执行命令</td></tr><tr><td><code>0 5 1，15 * *</code></td><td>在每月1日和15日的凌晨 5 点 0 分执行命令</td></tr><tr><td><code>40 4 * * 1-5</code></td><td>在每周一到周五的凌晨 4 点 40 分执行命令</td></tr><tr><td><code>*/10 4 * * *</code></td><td>在每天的凌晨 4 点，每隔 10 分钟执行一次命令</td></tr><tr><td><code>0 0 1，15 * 1</code></td><td>在每月1日和15日，每周一个0点0分都会执行命令<br />注意：星期几和几日最好不要同时出现，因为它们定义的都是天，非常容易让管理员混淆</td></tr></tbody></table><p><em>注意</em>：每个用户都可以执行自己的crontab任务</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Centos权限的浅解</title>
      <link href="/2023/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Centos%E6%9D%83%E9%99%90%E7%9A%84%E6%B5%85%E8%A7%A3/"/>
      <url>/2023/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Centos%E6%9D%83%E9%99%90%E7%9A%84%E6%B5%85%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Centos权限的浅解"><a href="#Centos权限的浅解" class="headerlink" title="Centos权限的浅解"></a>Centos权限的浅解</h1><pre><code class="shell">chomd 777 test.sh</code></pre><p><code>chomd</code>：修改文件及文件夹等的权限<br><code>777</code>：表示三个组的权限，第一个为文件所有者的权限，第二个为所属用户组的权限，第三个为其他用户的权限,7-&gt;rwx</p><ul><li>r-&gt;4:为读取权限</li><li>w-&gt;2:为写入权限</li><li>x-&gt;1:为执行权限<br><code>test.sh</code>：需要修改的目标<br>此外，在权限前面可添加-+&#x3D;等三个符号，分别表示减去权限，增加权限，唯一权限</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu idae 不能输入中文</title>
      <link href="/2023/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Ubuntu%20idae%20%E4%B8%8D%E8%83%BD%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87/"/>
      <url>/2023/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Ubuntu%20idae%20%E4%B8%8D%E8%83%BD%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-ubuntu-idae-不能输入中文date-2022-08-29-20-48-14-684updated-2022-10-13-14-45-23-084url-x2F-archives-x2F-ubuntuidae-bu-neng-shu-ru-zhong-wencategories-Ubuntu-Ideatags-Ubuntu-Idea"><a href="#title-ubuntu-idae-不能输入中文date-2022-08-29-20-48-14-684updated-2022-10-13-14-45-23-084url-x2F-archives-x2F-ubuntuidae-bu-neng-shu-ru-zhong-wencategories-Ubuntu-Ideatags-Ubuntu-Idea" class="headerlink" title="title: ubuntu idae 不能输入中文date: 2022-08-29 20:48:14.684updated: 2022-10-13 14:45:23.084url: &#x2F;archives&#x2F;ubuntuidae-bu-neng-shu-ru-zhong-wencategories:- Ubuntu- Ideatags:- Ubuntu- Idea"></a>title: ubuntu idae 不能输入中文<br>date: 2022-08-29 20:48:14.684<br>updated: 2022-10-13 14:45:23.084<br>url: &#x2F;archives&#x2F;ubuntuidae-bu-neng-shu-ru-zhong-wen<br>categories:<br>- Ubuntu<br>- Idea<br>tags:<br>- Ubuntu<br>- Idea</h2><p>解决方案<br>在<code>Edit Custom VM options</code>中配置如下参数</p><pre><code class="properties">-Drecreate.x11.input.method=true</code></pre>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows11改小状态栏</title>
      <link href="/2023/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows11%E6%94%B9%E5%B0%8F%E7%8A%B6%E6%80%81%E6%A0%8F/"/>
      <url>/2023/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows11%E6%94%B9%E5%B0%8F%E7%8A%B6%E6%80%81%E6%A0%8F/</url>
      
        <content type="html"><![CDATA[<p>在注册表如下路径</p><pre><code class="propreties">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced</code></pre><p>新建一个<code>DWORD</code><br>名称为：<code>TaskbarSi </code><br>值为：<code>0、1、2</code></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows删除BIOS内的引导选项</title>
      <link href="/2023/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows%E5%88%A0%E9%99%A4BIOS%E5%86%85%E7%9A%84%E5%BC%95%E5%AF%BC%E9%80%89%E9%A1%B9/"/>
      <url>/2023/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows%E5%88%A0%E9%99%A4BIOS%E5%86%85%E7%9A%84%E5%BC%95%E5%AF%BC%E9%80%89%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="删除BIOS内的UEFI引导选项"><a href="#删除BIOS内的UEFI引导选项" class="headerlink" title="删除BIOS内的UEFI引导选项"></a>删除BIOS内的UEFI引导选项</h1><ol><li>首先使用管理员打开<code>cmd</code>面板</li><li>输入<code>diskpart</code>进入工具</li><li>输入<code>list disk</code>查看磁盘窗台</li><li>使用<code>select disk [磁盘编号]</code>选择包含<code>UEFI</code>分区的磁盘</li><li>使用<code>list partition</code>列举出所有的分区</li><li>使用<code>select partition [分区编号]</code>选中<code>UTFI</code>分区</li><li>使用<code>assign letter [挂载号]</code>挂载分区为某一磁盘驱动器</li><li>打开文件管理器，发现有一个新的分区出现，就是<code>EFI</code>分区</li><li>我们没有权限打开<code>EFI</code>分区，所以使用管理员运行记事本，使用打开的方式进入到<code>EFI</code>分区</li><li>里面对应的文件夹就是不同系统的引导，删除对应即可，千万不能删除不知道的分区</li><li>最后使用<code>remove letter [挂载号]</code>移除分区即可</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL事务隔离级别</title>
      <link href="/2023/06/07/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
      <url>/2023/06/07/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL隔离级别"><a href="#SQL隔离级别" class="headerlink" title="SQL隔离级别"></a>SQL隔离级别</h1><ol><li><p>未提交读（Read Uncomminted）也叫 脏读（Dirty Reader）</p><p>在事物中的修改即使没有提交，对其他事物也是可见的。事务可以读取未被提交的数据</p></li><li><p>提交读（Read Comminted）也叫 不可重复读（Nonrepeatable Read）</p><p>一个事务开始时，只能“看到”已经提交的事物所做的修改。一个事务从开始知道提交之前，所作的任何修改对其他事务都是不可见</p></li><li><p>可重复读（Repeatable Read）</p><p>当前事务只能读取到在当前事务开启之前，其他事务已提交的数据。就算是在该事物开启前，其他事务已开始但是并未提交的事务也是不可见的。可重复读隔离级别还是无法解决另外一个幻读（Phantom Read) 的问题</p><p>幻读（Phantom Read）：指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行（Phantom Row）</p></li><li><p>可串行化（SERIALIZABLE）</p><p>通过强制事务串行执行，避免了前面所说的幻读的问题。简单来说，SERIALIZABLE会再读取的每一行数据上都加锁，所有可能导致大量的超时和锁争用的问题</p></li></ol><table><thead><tr><th>隔离级别</th><th>脏读可能性</th><th>不可重复读可能性</th><th>幻读可能性</th><th>加锁读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED 未提交读</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr><td>READ COMMITTED 提交读</td><td>No</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr><td>REPEATABLE READ 可重复读</td><td>No</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td>SERIALIZABLE 可串行化</td><td>No</td><td>No</td><td>No</td><td>Yes</td></tr></tbody></table><h2 id="数据库的四大特性（ACID）"><a href="#数据库的四大特性（ACID）" class="headerlink" title="数据库的四大特性（ACID）"></a>数据库的四大特性（ACID）</h2><ul><li><p>原子性（Atomicity）</p><p>事务内包含的所有操作要么全部成功，要么全部失败回滚；</p></li><li><p>一致性（Consistency）</p><p>不管任何时间有少个并发的事务，系统也必须保持一致；</p></li><li><p>隔离性（Isolation）</p><p>多个并发的事务的操作，在同一时间只能有一个事务执行（及串行的执行）；</p></li><li><p>持久性（Durability）</p><p>事务正确执行后，事务中对数据的操作不会回滚；</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL同表多外键</title>
      <link href="/2023/06/07/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%90%8C%E8%A1%A8%E5%A4%9A%E5%A4%96%E9%94%AE/"/>
      <url>/2023/06/07/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%90%8C%E8%A1%A8%E5%A4%9A%E5%A4%96%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL同表多外键"><a href="#MySQL同表多外键" class="headerlink" title="MySQL同表多外键"></a>MySQL同表多外键</h1><pre><code class="sql">drop database if exists test;create database if not exists test;use test;drop table if exists user;create table  if not exists user(    user_id bigint(18) comment &#39;用户ID&#39;,    user_name varchar(128) comment &#39;用户名称&#39;,    user_sex int(11) comment &#39;用户性别&#39;,    pass_word varchar(128) comment &#39;用户密码&#39;,    primary key (user_id))engine = innodb default charset = utf8;drop table if exists user_related;create table if not exists user_related(    related_id bigint(18) comment &#39;关系ID&#39;,    from_user_id bigint(18) comment &#39;用户ID&#39;,    to_user_id bigint(18) comment &#39;用户ID&#39;,    primary key (related_id),    foreign key (from_user_id) references user (user_id),    foreign key (to_user_id) references user (user_id))engine = innodb default charset = utf8;lock tables user write;insert into user(user_id,user_name,user_sex,pass_word) values (012345678911121314,&#39;用户1&#39;,1,&#39;123456&#39;);insert into user(user_id,user_name,user_sex,pass_word) values (012345678911121315,&#39;用户2&#39;,1,&#39;123456&#39;);unlock tables;lock tables user_related write;insert into user_related (related_id,from_user_id,to_user_id) values (012345678911121313,012345678911121314,012345678911121315);unlock tables;</code></pre><p>一个用户表设置多个外键，外键的名字可以不和原表一样，只要类型一致就可</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL命令集</title>
      <link href="/2023/06/07/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%91%BD%E4%BB%A4%E9%9B%86/"/>
      <url>/2023/06/07/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%91%BD%E4%BB%A4%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL命令集"><a href="#MySQL命令集" class="headerlink" title="MySQL命令集"></a>MySQL命令集</h1><p><strong>MySQL连接</strong></p><pre><code class="shell">#本地连接#password:可直接填写密码，或者直接回车，然后再保密输入密码mysql -u root -p &quot;password&quot;;#远程连接mysql -h &quot;ip&quot; -u root -p &quot;password&quot;;</code></pre><p><strong>修改密码</strong></p><p>进入mysql的bin目录下运行cmd</p><pre><code class="shell">#没有密码时可以省略 -p 参数mysqladmin  -uroot -p &quot;old password&quot; password &quot;new password&quot;;</code></pre><p><strong>新建用户</strong></p><pre><code class="shell">grant [select,insert,update,delete] on &quot;database&quot;.* to &quot;user name&quot;@&quot;login host&quot; identified by &quot;password&quot;;</code></pre><p>例如：新建一个number1用户，密码为123456，该用户只有对db1数据库所有的表有读取权限，且只能在MySQL所在的主机上登录，取消密码则重复这行命令，只是把密码置空</p><pre><code class="shell">grant select on db1.* to number1@localhost identified by &quot;123456&quot;;</code></pre><p><strong>查询连接</strong></p><pre><code class="shell"># 查询连接超时时间show variables like &#39;%timeout%&#39;;# 查询连接数show status like  &#39;Threads%&#39;;</code></pre><p>Threads_connected ：这个数值指的是打开的连接数.</p><p>Threads_running ：这个数值指的是激活的连接数，这个数值一般远低于connected数值.</p><p>Threads_connected 跟show processlist结果相同，表示当前连接数。准确的来说，Threads_running是代表当前并发数</p><pre><code class="shell">#查询最大连接数show variables like &#39;max_connections&#39;;#修改最大连接数#方法一set global max_connections = 1000;#方法二 修改my.conf配置文件：加上或者修改max_connectionsmax_connections = 1000</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL用户与授权</title>
      <link href="/2023/06/07/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%94%A8%E6%88%B7%E4%B8%8E%E6%8E%88%E6%9D%83/"/>
      <url>/2023/06/07/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%94%A8%E6%88%B7%E4%B8%8E%E6%8E%88%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL用户与授权"><a href="#MySQL用户与授权" class="headerlink" title="MySQL用户与授权"></a>MySQL用户与授权</h1><p><strong>1、创建用户</strong></p><pre><code class="shell">create user &#39;userName&#39;@&#39;host&#39; identified by &#39;passWord&#39;;</code></pre><ul><li><code>userName</code>：你需要创建的用户名</li><li><code>host</code>：指定该用户可以在那个主机上可以登录，本地为<code>localhost</code>，任意主机可以使用通配符<code>%</code></li><li><code>passWord</code>：指定该用户的登录密码，密码可以为空，</li></ul><p><strong>例如：</strong></p><pre><code class="shell">create user &#39;admin&#39;@&#39;localhost&#39; identified by &#39;123456&#39;;create user &#39;admin&#39;@&#39;192.168.1.101&#39; identified by &#39;123456&#39;;create user &#39;admin&#39;@&#39;%&#39; identified by &#39;123456&#39;;create user &#39;admin&#39;@&#39;%&#39; identified by &#39;&#39;;create user &#39;admin&#39;@&#39;%&#39;;</code></pre><p><strong>2、授权</strong></p><pre><code class="shell">grant &#39;privileges&#39; on &#39;database.table&#39; to &#39;userName&#39;@&#39;host&#39;</code></pre><ul><li><code>privileges</code>：用户操作的权限，如<code>select</code>，<code>insert</code>，<code>update</code>等，如果全部需要，使用<code>all</code></li><li><code>database</code>：授权的数据库名</li><li><code>table</code>：授权的数据库表名称，如果对该数据库的所有表都授权可使用<code>*</code>通配符</li></ul><p><strong>例如：</strong></p><pre><code class="shell">grant select, insert on test.user TO &#39;admin&#39;@&#39;%&#39;;grant all on test.* to &#39;admin&#39;@&#39;%&#39;;grant all on *.* to &#39;admin&#39;@&#39;%&#39;;</code></pre><p><strong>注意：</strong></p><p>用以上命令授权的用户不能给其他用户授权，如果需要使该用户可以授权，使用如下命令</p><pre><code class="shell">grant &#39;privileges&#39; on &#39;database.table&#39; to &#39;username&#39;@&#39;host&#39; with grant option;</code></pre><p><strong>3、设置与更改用户密码</strong></p><pre><code class="shell">set password for &#39;userName&#39;@&#39;host&#39; = password(&#39;passWord&#39;);</code></pre><ul><li><code>userName</code>：用户的名称</li><li><code>host</code>：用户登录范围</li><li><code>passWord</code>：用户的新密码</li></ul><p><strong>例如：</strong></p><pre><code class="shell">set password for &#39;admin&#39;@&#39;%&#39; = password(&quot;123456&quot;);</code></pre><p><strong>4、撤销用户权限</strong></p><pre><code class="shell">revoke &#39;privilege&#39; on &#39;database.table&#39; from &#39;username&#39;@&#39;host&#39;;</code></pre><ul><li><code>privilege</code>, <code>database</code>, <code>table</code>：同授权部分，参照授权部分</li></ul><p><strong>例如：</strong></p><pre><code class="shell">revoke select on *.* from &#39;admin&#39;@&#39;%&#39;;</code></pre><p><strong>注意</strong></p><p>假如你在给用户<code>&#39;pig&#39;@&#39;%&#39;</code>授权的时候是这样的（或类似的）：<code>GRANT SELECT ON test.user TO &#39;pig&#39;@&#39;%&#39;</code>，则在使用<code>REVOKE SELECT ON *.* FROM &#39;pig&#39;@&#39;%&#39;;</code>命令并不能撤销该用户对test数据库中user表的<code>SELECT</code> 操作。相反，如果授权使用的是<code>GRANT SELECT ON *.* TO &#39;pig&#39;@&#39;%&#39;;</code>则<code>REVOKE SELECT ON test.user FROM &#39;pig&#39;@&#39;%&#39;;</code>命令也不能撤销该用户对test数据库中user表的<code>Select</code>权限</p><p>具体信息可以用命令<code>SHOW GRANTS FOR &#39;pig&#39;@&#39;%&#39;;</code> 查看</p><p><strong>5、删除用户</strong></p><pre><code class="shell">drop user &#39;username&#39;@&#39;host&#39;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL视图</title>
      <link href="/2023/06/07/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E8%A7%86%E5%9B%BE/"/>
      <url>/2023/06/07/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p><strong>1、数据库的查询</strong></p><pre><code class="sql">//选择指定列select  name, age from demo1;//定义列的别名select name as 姓名 ,age as 年龄 from demo1;//当定义列的别名有空格的时候必须要用引号将标题括起来select name as &quot;student name&quot; ,age as &quot;student age&quot; from demo1;//替换查询结果的数据，end后面的字符串代替的是整个case...end语句，不然会直接输出整个case...end语句select name,age,  case    when age is null then &quot;尚未设置&quot;    when age &lt; 18 then &quot;未成年&quot;    else &quot;成年&quot;  end as &quot;是否成年&quot;  from demo1;//计算列值，把age扩大10被输出select name,age*10 as &quot;年龄x10&quot; from demo1;//消除重复的行select distinct  name,age,sex from demo1;</code></pre><p>聚合函数</p><table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td>count</td><td>求组中的项数，返回int类型整数</td></tr><tr><td>max</td><td>求最大值</td></tr><tr><td>min</td><td>求最小值</td></tr><tr><td>sum</td><td>返回表达式中所有值的和</td></tr><tr><td>avg</td><td>求组中值的平均值</td></tr><tr><td>std或stddev</td><td>返回给定表达式中所有值的标准值</td></tr><tr><td>variance</td><td>返回给定表达式中所有值的方差</td></tr></tbody></table><pre><code class="sql">select count(*) as &#39;一共有多少组&#39;  from demo1; select max(age) as &#39;年龄最大的为&#39; from demo1;select min(age) as &#39;年龄最小的为&#39; from demo1;select sum(age) as &#39;所有年龄之和&#39; from demo1;select avg(age) as &#39;平均年龄为&#39; from demo1;select std(age) as &quot;标准差&quot; from demo1;select variance(age) as &quot;方差&quot; from demo1;//返回一组指定列的的所有非null的值，这些值一个接一个的放置，中间用逗号隔开select group_concat(age) from demo1;</code></pre><table><thead><tr><th>函数名</th><th>解释</th></tr></thead><tbody><tr><td>group_concat()</td><td>返回一组指定列的的所有非null的值，这些值一个接一个的放置，中间用逗号隔开</td></tr><tr><td>rit_or()</td><td>与二进制里面的 或 相对应</td></tr><tr><td>rit_and()</td><td>与二进制里面的&amp;（与）相对应</td></tr><tr><td>rit_xor()</td><td>与二进制里卖弄的^（异或）相对应</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis命令</title>
      <link href="/2023/06/07/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/06/07/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p><a href="http://www.redis.cn/commands.html">官方命令文档地址</a></p><ul><li><p>五种数据类型</p><ul><li>String（字符串）</li><li>List（列表）</li><li>Hash（字典）</li><li>Set（集合）</li><li>Sorted Set（有序集合）</li></ul></li><li><p>String的常见命令</p><ul><li><pre><code class="shell">SET key value                   设置keyd的值valueGET key                         获得键key对应的值GETRANGE key start end          得到字符串的子字符串存放在一个键GETSET key value                设置键的字符串值，并返回旧值GETBIT key offset               返回存储在键位值的字符串值的偏移MGET key1 [key2..]              得到所有的给定键的值SETBIT key offset value         设置或清除该位在存储在键的字符串值偏移SETEX key seconds value         键到期时设置值SETNX key value                 设置键的值，只有当该键不存在SETRANGE key offset value       覆盖字符串的一部分从指定键的偏移STRLEN key                      得到存储在键的值的长度MSET key value [key value...]   设置多个键和多个值MSETNX key value [key value...] 设置多个键多个值，只有在当没有按键的存在时PSETEX key milliseconds value   设置键的毫秒值和到期时间INCR key                        增加键的整数值一次INCRBY key increment            由给定的数量递增键的整数值INCRBYFLOAT key increment       由给定的数量递增键的浮点值DECR key                        递减键一次的整数值DECRBY key decrement            由给定数目递减键的整数值APPEND key value                追加值到一个键DEL key                         如果存在删除键DUMP key                        返回存储在指定键的值的序列化版本EXISTS key                      此命令检查该键是否存在EXPIRE key seconds              指定键的过期时间EXPIREAT key timestamp          指定的键过期时间。在这里，时间是在Unix时间戳格式PEXPIRE key milliseconds        设置键以毫秒为单位到期PEXPIREAT key milliseconds-timestamp        设置键在Unix时间戳指定为毫秒到期KEYS pattern                    查找与指定模式匹配的所有键MOVE key db                     移动键到另一个数据库PERSIST key                     移除过期的键PTTL key                        以毫秒为单位获取剩余时间的到期键。TTL key                         获取键到期的剩余时间。RANDOMKEY                       从Redis返回随机键RENAME key newkey               更改键的名称RENAMENX key newkey             重命名键，如果新的键不存在TYPE key                        返回存储在键的数据类型的值</code></pre></li></ul></li><li><p>List列表常见命令</p><ul><li><pre><code class="shell">BLPOP key1 [key2 ] timeout 取出并获取列表中的第一个元素，或阻塞，直到有可用BRPOP key1 [key2 ] timeout 取出并获取列表中的最后一个元素，或阻塞，直到有可用BRPOPLPUSH source destination timeout 从列表中弹出一个值，它推到另一个列表并返回它;或阻塞，直到有可用LINDEX key index 从一个列表其索引获取对应的元素LINSERT key BEFORE|AFTER pivot value 在列表中的其他元素之后或之前插入一个元素LLEN key 获取列表的长度LPOP key 获取并取出列表中的第一个元素LPUSH key value1 [value2] 在前面加上一个或多个值的列表LPUSHX key value 在前面加上一个值列表，仅当列表中存在LRANGE key start stop 从一个列表获取各种元素LREM key count value 从列表中删除元素LSET key index value 在列表中的索引设置一个元素的值LTRIM key start stop 修剪列表到指定的范围内RPOP key 取出并获取列表中的最后一个元素RPOPLPUSH source destination 删除最后一个元素的列表，将其附加到另一个列表并返回它RPUSH key value1 [value2] 添加一个或多个值到列表RPUSHX key value 添加一个值列表，仅当列表中存在</code></pre></li></ul></li><li><p>Hash的常见命令</p><ul><li><pre><code class="shell">HDEL key field[field...] 删除对象的一个或几个属性域，不存在的属性将被忽略HEXISTS key field 查看对象是否存在该属性域HGET key field 获取对象中该field属性域的值HGETALL key 获取对象的所有属性域和值HINCRBY key field value 将该对象中指定域的值增加给定的value，原子自增操作，只能是integer的属性值可以使用HINCRBYFLOAT key field increment 将该对象中指定域的值增加给定的浮点数HKEYS key 获取对象的所有属性字段HVALS key 获取对象的所有属性值HLEN key 获取对象的所有属性字段的总数HMGET key field[field...] 获取对象的一个或多个指定字段的值HSET key field value 设置对象指定字段的值HMSET key field value [field value ...] 同时设置对象中一个或多个字段的值HSETNX key field value 只在对象不存在指定的字段时才设置字段的值HSTRLEN key field 返回对象指定field的value的字符串长度，如果该对象或者field不存在，返回0.HSCAN key cursor [MATCH pattern] [COUNT count] 类似SCAN命令</code></pre></li></ul></li><li><p>Set的常见命令</p><ul><li><pre><code class="shell">SADD key member [member ...] 添加一个或者多个元素到集合(set)里SCARD key 获取集合里面的元素数量SDIFF key [key ...] 获得队列不存在的元素SDIFFSTORE destination key [key ...] 获得队列不存在的元素，并存储在一个关键的结果集SINTER key [key ...] 获得两个集合的交集SINTERSTORE destination key [key ...] 获得两个集合的交集，并存储在一个集合中SISMEMBER key member 确定一个给定的值是一个集合的成员SMEMBERS key 获取集合里面的所有keySMOVE source destination member 移动集合里面的一个key到另一个集合SPOP key [count] 获取并删除一个集合里面的元素SRANDMEMBER key [count] 从集合里面随机获取一个元素SREM key member [member ...] 从集合里删除一个或多个元素，不存在的元素会被忽略SUNION key [key ...] 添加多个set元素SUNIONSTORE destination key [key ...] 合并set元素，并将结果存入新的set里面SSCAN key cursor [MATCH pattern] [COUNT count] 迭代set里面的元素</code></pre></li></ul></li><li><p>Sorted Set的常见命令</p><ul><li><pre><code class="shell">ZADD key score1 member1 [score2 member2] 添加一个或多个成员到有序集合，或者如果它已经存在更新其分数ZCARD key 得到的有序集合成员的数量ZCOUNT key min max 计算一个有序集合成员与给定值范围内的分数ZINCRBY key increment member 在有序集合增加成员的分数ZINTERSTORE destination numkeys key [key ...] 多重交叉排序集合，并存储生成一个新的键有序集合。ZLEXCOUNT key min max 计算一个给定的字典范围之间的有序集合成员的数量ZRANGE key start stop [WITHSCORES] 由索引返回一个成员范围的有序集合（从低到高）ZRANGEBYLEX key min max [LIMIT offset count]返回一个成员范围的有序集合（由字典范围）ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] 返回有序集key中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员，有序集成员按 score 值递增(从小到大)次序排列ZRANK key member 确定成员的索引中有序集合ZREM key member [member ...] 从有序集合中删除一个或多个成员，不存在的成员将被忽略ZREMRANGEBYLEX key min max 删除所有成员在给定的字典范围之间的有序集合ZREMRANGEBYRANK key start stop 在给定的索引之内删除所有成员的有序集合ZREMRANGEBYSCORE key min max 在给定的分数之内删除所有成员的有序集合ZREVRANGE key start stop [WITHSCORES] 返回一个成员范围的有序集合，通过索引，以分数排序，从高分到低分ZREVRANGEBYSCORE key max min [WITHSCORES] 返回一个成员范围的有序集合，以socre排序从高到低ZREVRANK key member 确定一个有序集合成员的索引，以分数排序，从高分到低分ZSCORE key member 获取给定成员相关联的分数在一个有序集合ZUNIONSTORE destination numkeys key [key ...] 添加多个集排序，所得排序集合存储在一个新的键ZSCAN key cursor [MATCH pattern] [COUNT count] 增量迭代排序元素集和相关的分数</code></pre></li></ul></li></ul><hr><p><strong>常用命令</strong></p><ul><li><code>config get requirepass</code>   查看当前redis是否由设置密码，显示<code>requirepass</code> <code>null</code>为没有密码</li><li><code>config set requirepass 123456</code>   设置密码</li><li><code>redis-cli --raw -h &#39;ip&#39; -p &#39;port&#39;</code>   连接方式 </li><li><code>auth 123456</code>   密码验证</li></ul><p><strong>配置文件修改</strong></p><ul><li>永久密码修改<ul><li>进入redis.conf配置文件，找到requirepass属性，修改成自己想要的密码，保存重启redis即可</li></ul></li></ul><hr><p><strong>Redis与代码</strong></p><ul><li><p>连接的jar包叫做jedis</p><p>基础使用样例，其方法名称和命令形式基本一致</p><pre><code class="java">Jedis jedis = new Jedis(&quot;localhost&quot;);jedis.set(&quot;key1&quot;,&quot;value1&quot;);String value = jedis.get(&quot;key1&quot;);</code></pre></li><li><p>与Spring等框架的时候记得配置好配置文件</p></li><li><p>Redis的图形化界面工具-RedisClient</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis持久化</title>
      <link href="/2023/06/07/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2023/06/07/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="redis的持久化"><a href="#redis的持久化" class="headerlink" title="redis的持久化"></a>redis的持久化</h1><ol><li>aop（append only file）<br> 把每一次的数据变化都写入到本地文件 ——— 全持久化模式以日志的形式记录 每一次的写、删操作，以文本的形式记录</li><li>rdb<br> 定时把redis中的数据写入到本地文件 ——— 半持久化模式<br> fork一个字进程，把数据写入临时文件，然后在替换掉本地的文件，使用二进制压缩</li></ol><h2 id="RDB持久化配置"><a href="#RDB持久化配置" class="headerlink" title="RDB持久化配置"></a>RDB持久化配置</h2><p>Redis会将数据集的快照dump到dump.rdb文件中。此外，我们也可以通过配置文件来修改Redis服务器dump快照的频率，在打开6379.conf文件之后，我们搜索save，可以看到下面的配置信息：</p><p>save 900 1       #在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。<br>save 300 10      #在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。<br>save 60 10000    #在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照。</p><h2 id="AOF持久化配置"><a href="#AOF持久化配置" class="headerlink" title="AOF持久化配置"></a>AOF持久化配置</h2><p>在Redis的配置文件中存在三种同步方式，它们分别是：</p><p>appendfsync always   #每次有数据修改发生时都会写入AOF文件。<br>appendfsync everysec #每秒钟同步一次，该策略为AOF的缺省策略。<br>appendfsync no     #从不同步。高效但是数据不会被持久化。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis描述</title>
      <link href="/2023/06/07/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E6%8F%8F%E8%BF%B0/"/>
      <url>/2023/06/07/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E6%8F%8F%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="redis-understand"><a href="#redis-understand" class="headerlink" title="redis understand"></a>redis understand</h1><p><strong>概述</strong></p><p>redis全称是 remote dictionary server（远程字典服务），是一个ANSI C语言编写、支持网络、可基于内存也可以持久化的日志型的 kay-value 数据库。</p><p>于mysql不同的是，redis的信息是存在于内存当中，读写速度快，每秒读写（iops）10w+，因此redis常被应用自缓存，另外redis也经常被用作分布式锁，redis支持事务、持久化、lua脚本、lru驱动事件、多种集群方案。</p><p><strong>数据类型</strong></p><p>redis有如下五种基础数据类型</p><ol><li>String（字符串）</li><li>Hash（哈希）</li><li>List（列表）</li><li>Set（集合）</li><li>zset（有序集合）</li></ol><p>三种特殊的数据结构类型</p><ol><li>Geospatial</li><li>Hyperloglog</li><li>Bitmap</li></ol><p><strong>缓存问题</strong></p><p>穿透：</p><p>指查询一个不存在的数据，redis查不到就往db中差，db也查不到就无法创建缓存，一直查就会一直请求数据库，进而给db带来压力</p><p>解决方案：</p><ol><li>接口API验证，避免非法请求，过滤非法值</li><li>如果查询为空，我们也设置一个缓存，或者叫默认值，每次返回默认值即可，直到下次写入刷新，也要给缓存设置一定时间的过期</li><li>布隆过滤，</li></ol><p>雪崩：</p><p>指某一时刻，redis中大量的数据过期，而同时查询的数据量巨大，那么请求都将直接访问db，引起db的压力过大深圳down机</p><p>解决方案：</p><ol><li>把redis数据过期的时间做微调，也就是说，我们在给定的时间上，做微量偏移，使得过期的时间分布在一个范围内，而不是聚集在某一时刻</li><li>单个redis宕机也会造成，这个时候要使用redis的集群服务</li></ol><p>击穿：</p><p>击穿与雪崩很像，击穿是指某一个key过期，而当前的key又有很大的访问量，造成全部去访问db，造成压力过大宕机</p><p>解决方案：</p><ol><li>使用互斥锁方案，缓存失效的时候，不马上去加载db，而是先使用某些带返回的原子操作命令（就是给redis设置一个值，先让这个给值顶着，然后我跑去db拿数据刷新过来，保证只有一个db操作进入），成功了再去数据库加载数据</li><li>永不过期，指不设置过期时间，在快过期的时候，由异步线程去刷新数据</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows安装MySQL</title>
      <link href="/2023/06/07/%E6%95%B0%E6%8D%AE%E5%BA%93/Windows%E5%AE%89%E8%A3%85MySQL/"/>
      <url>/2023/06/07/%E6%95%B0%E6%8D%AE%E5%BA%93/Windows%E5%AE%89%E8%A3%85MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows下MySQL的安装"><a href="#Windows下MySQL的安装" class="headerlink" title="Windows下MySQL的安装"></a>Windows下MySQL的安装</h1><p>首先下载MySQL的的压缩包（MySQL社区版）</p><p><a href="https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.37-winx64.zip">MySQL5.7社区版</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>如果以前安装过其它版本的MySQL那么需要先卸载mysql的服务在进行安装<br>卸载方式：以管理员身份进入CMD控制台，然后输入一下命令进行删除服务<br>如果未安装则可以忽略这一步骤：mysql是服务的名称</p><pre><code class="shell">sc delete mysql</code></pre><h2 id="1、MySQL的解压"><a href="#1、MySQL的解压" class="headerlink" title="1、MySQL的解压"></a>1、MySQL的解压</h2><p>将下载好的mysql的压缩包解压，并且把解压之后的mysql-8.0.15-winx64文件夹放到安装文件夹<br>我的是放在：D:\Software\MySQL\mysql-8.0.15-winx64</p><h2 id="2、配置环境变量"><a href="#2、配置环境变量" class="headerlink" title="2、配置环境变量"></a>2、配置环境变量</h2><p>右键我的计算机-&gt;属性-&gt;高级系统设置-&gt;环境变量<br>新建系统变量</p><pre><code class="shell">变量名称：MYSQL_HOME变量路径：D:\Software\MySQL\mysql-8.0.15-winx64\bin</code></pre><p>修改path变量，加入</p><pre><code class="shell">%MYSQL_HOME%\bin</code></pre><p><strong>注意：</strong>如果失败，可以创建一个指定初始配置文件(我现在这个版本是没有配置的)<br>初始化mysql前，可以通过ini文件来指定部分初始配置，比如<code>basedir</code>和<code>datadir</code>等，当然，也可以不指定利用默认的，参考文档<a href="https://dev.mysql.com/doc/refman/8.0/en/windows-create-option-file.html">官方文档</a><br>在mysql的根目录下，创建mysql.ini文件，加入下面内容</p><pre><code class="yml">[mysqld]# set basedir to your installation pathbasedir=D:\Software\MySQL\mysql-8.0.15-winx64# set datadir to the location of your data directorydatadir=D:\Software\MySQL\mysql-8.0.15-winx64\data</code></pre><h2 id="3、初始化"><a href="#3、初始化" class="headerlink" title="3、初始化"></a>3、初始化</h2><p>打开cmd控制台，输入初始化命令（由于配置了系统的环境变量，所以不需要进入到D:\Software\MySQL\mysql-8.0.15-winx64\bin下）</p><pre><code class="shell">//生成临时密码mysqlid --initialize --console</code></pre><p>或者</p><pre><code class="shell">//空密码mysqld --initialize-insecure --console</code></pre><p>如果选择临时密码，控制台会有以下输出，可以看到里面有临时密码（temporary password is generated for root@localhost:后面的值，注意去掉空格），请一定要记住，当然你如果不想记住也可以，只是需要再折腾一下去重置密码</p><pre><code class="yml">2018-08-15T02:55:43.924361Z 0 [System] [MY-013169] [Server] C:\MyPrograms\mysql-8.0.12-winx64\bin\mysqld.exe (mysqld 8.0.12) initializing of server in progress as process 120402018-08-15T02:55:55.962035Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: XCeQtsgMO7-F2018-08-15T02:56:03.261174Z 0 [System] [MY-013170] [Server] C:\MyPrograms\mysql-8.0.12-winx64\bin\mysqld.exe (mysqld 8.0.12) initializing of server has completed</code></pre><h2 id="4、安装windows服务"><a href="#4、安装windows服务" class="headerlink" title="4、安装windows服务"></a>4、安装windows服务</h2><p>用管理员身份打开CMD，在里面输入如下命令</p><pre><code class="shell">//serviceName为服务名，不输入默认为mysqlmysqld --install [serviceName]</code></pre><p>如果看到下面内容，则证明服务安装成功</p><pre><code>Service successfully installed.</code></pre><h2 id="5、启动服务"><a href="#5、启动服务" class="headerlink" title="5、启动服务"></a>5、启动服务</h2><p>还是用管理员身份打开CMD，输入如下命令</p><pre><code class="shell">net start mysql//以下输出证明启动成功MySQL 服务正在启动 ..MySQL 服务已经启动成功。//如果你要关闭的话net stop mysql</code></pre><h2 id="6、更改密码"><a href="#6、更改密码" class="headerlink" title="6、更改密码"></a>6、更改密码</h2><p>连接到mysql</p><pre><code class="shell">//下面-p后面的内容就是临时密码mysql -uroot -pXCeQtsgMO7-F</code></pre><p>修改密码</p><pre><code class="shell">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;newpassword&#39;;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>1、环境变量是为了在命令行CMD中更加方便使用mysql命令；</li><li>2、如果有之前有安装过其他版本mysql，记得先卸载并删除服务；</li><li>3、安装完记得登录并修改密码，不论是采用空密码还是临时密码；</li><li>4、当然，命令行终归是不方便的，现在有很多可视化界面，如：Navicat等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>B树&amp;B+树</title>
      <link href="/2023/06/07/%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/B%E6%A0%91&amp;B+%E6%A0%91/"/>
      <url>/2023/06/07/%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/B%E6%A0%91&amp;B+%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-B-Treedate-2022-04-26-13-44-11-89updated-2022-08-04-18-30-16-893url-x2F-archives-x2F-btreecategories-tags"><a href="#title-B-Treedate-2022-04-26-13-44-11-89updated-2022-08-04-18-30-16-893url-x2F-archives-x2F-btreecategories-tags" class="headerlink" title="title: B Treedate: 2022-04-26 13:44:11.89updated: 2022-08-04 18:30:16.893url: &#x2F;archives&#x2F;btreecategories:tags: "></a>title: B Tree<br>date: 2022-04-26 13:44:11.89<br>updated: 2022-08-04 18:30:16.893<br>url: &#x2F;archives&#x2F;btree<br>categories:<br>tags: </h2><h1 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B Tree"></a>B Tree</h1><p>mi’g’c</p><ul><li>叶子节点：最后的那一场节点</li><li>非叶子节点：除去最后的那一层节点</li><li>阶：B树中所有孩子节点数的最大值</li><li>度：数的高度，一般不包括叶子节点那一层</li></ul><p>规则：</p><ol><li>树中每个节点最多只能有M（M为阶）颗子树</li></ol>]]></content>
      
      
      <categories>
          
          <category> 理论体系 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO与NIO</title>
      <link href="/2023/06/07/%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/IO%E4%B8%8ENIO/"/>
      <url>/2023/06/07/%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/IO%E4%B8%8ENIO/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-IO与NIOdate-2022-03-31-09-16-30-027updated-2022-10-13-15-10-56-133url-x2F-archives-x2F-io-yu-niocategories-理论体系tags-理论体系-IO"><a href="#title-IO与NIOdate-2022-03-31-09-16-30-027updated-2022-10-13-15-10-56-133url-x2F-archives-x2F-io-yu-niocategories-理论体系tags-理论体系-IO" class="headerlink" title="title: IO与NIOdate: 2022-03-31 09:16:30.027updated: 2022-10-13 15:10:56.133url: &#x2F;archives&#x2F;io-yu-niocategories:- 理论体系tags:- 理论体系- IO"></a>title: IO与NIO<br>date: 2022-03-31 09:16:30.027<br>updated: 2022-10-13 15:10:56.133<br>url: &#x2F;archives&#x2F;io-yu-nio<br>categories:<br>- 理论体系<br>tags:<br>- 理论体系<br>- IO</h2><h2 id="1、阻塞与非阻塞"><a href="#1、阻塞与非阻塞" class="headerlink" title="1、阻塞与非阻塞"></a>1、阻塞与非阻塞</h2><p>阻塞与非阻塞是描述进程在访问某个资源时，数据是否准备就绪的的一种处理方式。当数据没有准备就绪时：</p><ul><li>阻塞：线程持续等待资源中数据准备完成，直到返回响应结果。</li><li>非阻塞：线程直接返回结果，不会持续等待资源准备数据结束后才响应结果。</li></ul><h2 id="2、同步与异步"><a href="#2、同步与异步" class="headerlink" title="2、同步与异步"></a>2、同步与异步</h2><ul><li>同步与异步是指访问数据的机制，同步一般指主动请求并等待IO操作完成的方式。</li><li>异步则指主动请求数据后便可以继续处理其它任务，随后等待IO操作完毕的通知。</li></ul><p>老王烧开水：</p><ol><li>普通水壶煮水，站在旁边，主动的看水开了没有？同步的阻塞</li><li>普通水壶煮水，去干点别的事，每过一段时间去看看水开了没有，水没开就走人。 同步非阻塞</li><li>响水壶煮水，站在旁边，不会每过一段时间主动看水开了没有。如果水开了，水壶自动通知他。 异步阻塞</li><li>响水壶煮水，去干点别的事，如果水开了，水壶自动通知他。异步非阻塞</li></ol><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="1、传统BIO模型"><a href="#1、传统BIO模型" class="headerlink" title="1、传统BIO模型"></a>1、传统BIO模型</h3><p>传统BIO是一种同步的阻塞IO，IO在进行读写时，该线程将被阻塞，线程无法进行其它操作。<br> IO流在读取时，会阻塞。直到发生以下情况：1、有数据可以读取。2、数据读取完成。3、发生异常</p><h3 id="2、伪异步IO模型"><a href="#2、伪异步IO模型" class="headerlink" title="2、伪异步IO模型"></a>2、伪异步IO模型</h3><p>以传统BIO模型为基础，通过线程池的方式维护所有的IO线程，实现相对高效的线程开销及管理。</p><h3 id="3、NIO模型"><a href="#3、NIO模型" class="headerlink" title="3、NIO模型"></a>3、NIO模型</h3><p>NIO（JDK1.4）模型是一种同步非阻塞IO，主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector（多路复用器）。传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(多路复用器)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。<br> NIO和传统IO（一下简称IO）之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。<br> IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p><h3 id="NIO优点："><a href="#NIO优点：" class="headerlink" title="NIO优点："></a>NIO优点：</h3><ol><li>通过Channel注册到Selector上的状态来实现一种客户端与服务端的通信。</li><li>Channel中数据的读取是通过Buffer , 一种非阻塞的读取方式。</li><li>Selector 多路复用器  单线程模型，  线程的资源开销相对比较小。</li></ol><h4 id="Channel-通道"><a href="#Channel-通道" class="headerlink" title="Channel(通道)"></a>Channel(通道)</h4><p>传统IO操作对read()或write()方法的调用，可能会因为没有数据可读&#x2F;可写而阻塞，直到有数据响应。也就是说读写数据的IO调用，可能会无限期的阻塞等待，效率依赖网络传输的速度。最重要的是在调用一个方法前，无法知道是否会被阻塞。</p><p>NIO的Channel抽象了一个重要特征就是可以通过配置它的阻塞行为，来实现非阻塞式的通道。</p><p>Channel是一个双向通道，与传统IO操作只允许单向的读写不同的是，NIO的Channel允许在一个通道上进行读和写的操作。</p><p>FileChannel:文件</p><p>SocketChannel:</p><p>ServerSocketChannel:</p><p>DatagramChannel: UDP</p><h4 id="Buffer-缓冲区"><a href="#Buffer-缓冲区" class="headerlink" title="Buffer(缓冲区)"></a>Buffer(缓冲区)</h4><p>Bufer顾名思义，它是一个缓冲区，实际上是一个容器，一个连续数组。Channel提供从文件、网络读取数据的渠道，但是读写的数据都必须经过Buffer。</p><p><img src="/upload/2022/03/13449209-300fd48a7251c327.png" alt="13449209-300fd48a7251c327"></p><p>Buffer(缓冲区)</p><p>Buffer缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该模块内存。为了理解Buffer的工作原理，需要熟悉它的三个属性：capacity、position和limit。</p><p>position和limit的含义取决于Buffer处在读模式还是写模式。不管Buffer处在什么模式，capacity的含义总是一样的。见下图：</p><p><img src="/upload/2022/03/13449209-d261cbcb9b9ed88f.png" alt="13449209-d261cbcb9b9ed88f"></p><p>capacity、position和limit</p><ul><li>capacity：作为一个内存块，Buffer有固定的大小值，也叫作“capacity”，只能往其中写入capacity个byte、long、char等类型。一旦Buffer满了，需要将其清空（通过读数据或者清楚数据）才能继续写数据。</li><li>position：当你写数据到Buffer中时，position表示当前的位置。出事的position值为0，当写入一个字节数据到Buffer中后，position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity-1。当读取数据时，也是从某个特定位置读，讲Buffer从写模式切换到读模式，position会被重置为0。当从Buffer的position处读取一个字节数据后，position向前移动到下一个可读的位置。</li><li>limit：在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。 写模式下，limit等于Buffer的capacity。当切换Buffer到读模式时， limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是position）</li></ul><h4 id="Buffer的分配："><a href="#Buffer的分配：" class="headerlink" title="Buffer的分配："></a>Buffer的分配：</h4><p>对Buffer对象的操作必须首先进行分配，Buffer提供一个allocate(int capacity)方法分配一个指定字节大小的对象。<br> 向Buffer中写数据：写数据到Buffer中有两种方式：<br> 1.从channel写到Buffer</p><pre><code class="cpp">int bytes = channel.read(buf); //将channel中的数据读取到buf中</code></pre><p>2.通过Buffer的put()方法写到Buffer</p><pre><code class="csharp">buf.put(byte); //将数据通过put()方法写入到buf中</code></pre><ul><li>flip()方法：将Buffer从写模式切换到读模式，调用flip()方法会将position设置为0，并将limit设置为之前的position的值。<br> 从Buffer中读数据：从Buffer中读数据有两种方式：<br> 1.从Buffer读取数据到Channel</li></ul><pre><code class="cpp">int bytes = channel.write(buf); //将buf中的数据读取到channel中</code></pre><p>2.通过Buffer的get()方法读取数据</p><pre><code class="csharp">byte bt = buf.get(); //从buf中读取一个byte</code></pre><ul><li>rewind()方法：Buffer.rewind()方法将position设置为0，使得可以重读Buffer中的所有数据，limit保持不变。</li><li>clear()与compact()方法：一旦读完Buffer中的数据，需要让Buffer准备好再次被写入，可以通过clear()或compact()方法完成。如果调用的是clear()方法，position将被设置为0，limit设置为capacity的值。但是Buffer并未被清空，只是通过这些标记告诉我们可以从哪里开始往Buffer中写入多少数据。如果Buffer中还有一些未读的数据，调用clear()方法将被”遗忘 “。compact()方法将所有未读的数据拷贝到Buffer起始处，然后将position设置到最后一个未读元素的后面，limit属性依然设置为capacity。可以使得Buffer中的未读数据还可以在后续中被使用。</li><li>mark()与reset()方法：通过调用Buffer.mark()方法可以标记一个特定的position，之后可以通过调用Buffer.reset()恢复到这个position上。</li></ul><h4 id="Selector-多路复用器"><a href="#Selector-多路复用器" class="headerlink" title="Selector(多路复用器)"></a>Selector(多路复用器)</h4><p>Selector与Channel是相互配合使用的，将Channel注册在Selector上之后，才可以正确的使用Selector，但此时Channel必须为非阻塞模式。Selector可以监听Channel的四种状态（Connect、Accept、Read、Write），当监听到某一Channel的某个状态时，才允许对Channel进行相应的操作。</p><ul><li>Connect：某一个客户端连接成功后</li><li>Accept：准备好进行连接</li><li>Read:可读</li><li>Write:可写</li></ul><p>作者：林亚希<br>链接：<a href="https://www.jianshu.com/p/5bb812ca5f8e">https://www.jianshu.com/p/5bb812ca5f8e</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 理论体系 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树定义</title>
      <link href="/2023/06/07/%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9A%E4%B9%89/"/>
      <url>/2023/06/07/%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-二叉树定义date-2022-07-11-22-58-34-662updated-2022-08-04-18-30-08-316url-x2F-archives-x2F-二叉树定义categories-tags"><a href="#title-二叉树定义date-2022-07-11-22-58-34-662updated-2022-08-04-18-30-08-316url-x2F-archives-x2F-二叉树定义categories-tags" class="headerlink" title="title: 二叉树定义date: 2022-07-11 22:58:34.662updated: 2022-08-04 18:30:08.316url: &#x2F;archives&#x2F;二叉树定义categories:tags: "></a>title: 二叉树定义<br>date: 2022-07-11 22:58:34.662<br>updated: 2022-08-04 18:30:08.316<br>url: &#x2F;archives&#x2F;二叉树定义<br>categories:<br>tags: </h2><h4 id="前、中、后序遍历"><a href="#前、中、后序遍历" class="headerlink" title="前、中、后序遍历"></a>前、中、后序遍历</h4><pre><code class="mermaid">graph TBA((A))B((B))C((C))D((D))E((E))A–&gt;BA–&gt;CB–&gt;DB–&gt;E</code></pre>]]></content>
      
      
      <categories>
          
          <category> 理论体系 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务的七种方案</title>
      <link href="/2023/06/07/%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%B8%83%E7%A7%8D%E6%96%B9%E6%A1%88/"/>
      <url>/2023/06/07/%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%B8%83%E7%A7%8D%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="分布式事务的七种方案"><a href="#分布式事务的七种方案" class="headerlink" title="分布式事务的七种方案"></a>分布式事务的七种方案</h2><p>随着业务的快速发展、业务复杂度越来越高，几乎每个公司的系统都会从单体走向分布式，特别是转向微服务架构。随之而来就必然遇到分布式事务这个难题，这篇文章总结了分布式事务最经典的解决方案。</p><h3 id="◆-基础理论"><a href="#◆-基础理论" class="headerlink" title="◆ 基础理论"></a><strong>◆</strong> <strong>基础理论</strong></h3><p>在讲解具体方案之前，我们先了解一下分布式事务所涉及到的基础理论知识。</p><p>我们拿转账作为例子，A需要转100元给B，那么需要给A的余额-100元，给B的余额+100元，整个转账要保证，A-100和B+100同时成功，或者同时失败。看看在各种场景下，是如何解决这个问题的。</p><h3 id="◆-事务"><a href="#◆-事务" class="headerlink" title="◆ 事务"></a><strong>◆</strong> 事务</h3><p>把多条语句作为一个整体进行操作的功能，被称为数据库事务。数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。</p><p>事务具有 4 个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为 ACID 特性。</p><ul><li>Atomicity（原子性）：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复到事务开始前的状态，就像这个事务从来没有执行过一样。</li><li>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。完整性包括外键约束、应用定义的等约束不会被破坏。</li><li>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。</li><li>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><h3 id="◆-分布式事务"><a href="#◆-分布式事务" class="headerlink" title="◆ 分布式事务"></a><strong>◆</strong> 分布式事务</h3><p>银行跨行转账业务是一个典型分布式事务场景，假设A需要跨行转账给B，那么就涉及两个银行的数据，无法通过一个数据库的本地事务保证转账的ACID，只能够通过分布式事务来解决。</p><p>分布式事务就是指事务的发起者、资源及资源管理器和事务协调者分别位于分布式系统的不同节点之上。在上述转账的业务中，用户A-100操作和用户B+100操作不是位于同一个节点上。本质上来说，分布式事务就是为了保证在分布式场景下，数据操作的正确执行。</p><p>分布式事务在分布式环境下，为了满足可用性、性能与降级服务的需要，降低一致性与隔离性的要求，一方面遵循 BASE 理论（BASE相关理论，涉及内容非常多，感兴趣的同学，可以参考BASE理论）：</p><p>基本业务可用性（Basic Availability）<br>柔性状态（Soft state）<br>最终一致性（Eventual consistency）<br>同样的，分布式事务也部分遵循 ACID 规范：</p><p>原子性：严格遵循<br>一致性：事务完成后的一致性严格遵循；事务中的一致性可适当放宽<br>隔离性：并行事务间不可影响；事务中间结果可见性允许安全放宽<br>持久性：严格遵循</p><h3 id="◆-分布式事务的解决方案"><a href="#◆-分布式事务的解决方案" class="headerlink" title="◆ 分布式事务的解决方案"></a><strong>◆</strong> <strong>分布式事务的解决方案</strong></h3><h3 id="◆-两阶段提交-x2F-XA"><a href="#◆-两阶段提交-x2F-XA" class="headerlink" title="◆ 两阶段提交&#x2F;XA"></a><strong>◆</strong> 两阶段提交&#x2F;XA</h3><p>XA是由X&#x2F;Open组织提出的分布式事务的规范，XA规范主要定义了(全局)事务管理器(TM)和(局部)资源管理器(RM)之间的接口。本地的数据库如mysql在XA中扮演的是RM角色</p><p>XA一共分为两阶段：</p><p>第一阶段（prepare）：即所有的参与者RM准备执行事务并锁住需要的资源。参与者ready时，向TM报告已准备就绪。<br>第二阶段 (commit&#x2F;rollback)：当事务管理者(TM)确认所有参与者(RM)都ready后，向所有参与者发送commit命令。<br>目前主流的数据库基本都支持XA事务，包括mysql、oracle、sqlserver、postgre</p><p>XA 事务由一个或多个资源管理器（RM）、一个事务管理器（TM）和一个应用程序（ApplicationProgram）组成。</p><p>把上面的转账作为例子，一个成功完成的XA事务时序图如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/35b866cfc4284a68903610140abb8563.png"></p><p>如果有任何一个参与者prepare失败，那么TM会通知所有完成prepare的参与者进行回滚。</p><p>XA事务的特点是：</p><ul><li>简单易理解，开发较容易</li><li>对资源进行了长时间的锁定，并发度低</li></ul><p>如果读者想要进一步研究XA，go语言可参考DTM，java语言可参考seata</p><h3 id="◆-SAGA"><a href="#◆-SAGA" class="headerlink" title="◆  SAGA"></a><strong>◆</strong>  SAGA</h3><p>Saga是这一篇数据库论文saga提到的一个方案。其核心思想是将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。</p><p>把上面的转账作为例子，一个成功完成的SAGA事务时序图如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/9b08a9a34f19b376780cc949f76efb57.png"></p><p>SAGA事务的特点：</p><ul><li>并发度高，不用像XA事务那样长期锁定资源</li><li>需要定义正常操作以及补偿操作，开发量比XA大</li><li>一致性较弱，对于转账，可能发生A用户已扣款，最后转账又失败的情况</li></ul><p>论文里面的SAGA内容较多，包括两种恢复策略，包括分支事务并发执行，我们这里的讨论，仅包括最简单的SAGA</p><p>SAGA适用的场景较多，长事务适用，对中间结果不敏感的业务场景适用</p><p>如果读者想要进一步研究SAGA，go语言可参考DTM，java语言可参考seata</p><h3 id="◆-TCC"><a href="#◆-TCC" class="headerlink" title="◆  TCC"></a><strong>◆</strong>  TCC</h3><p>关于 TCC（Try-Confirm-Cancel）的概念，最早是由 Pat Helland 于 2007 年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。</p><p><strong>TCC分为3个阶段</strong></p><ul><li>Try 阶段：尝试执行，完成所有业务检查（一致性）, 预留必须业务资源（准隔离性）</li><li>Confirm 阶段：确认执行真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源，Confirm 操作要求具备幂等设计，Confirm 失败后需要进行重试。</li><li>Cancel 阶段：取消执行，释放 Try 阶段预留的业务资源。Cancel 阶段的异常和 Confirm 阶段异常处理方案基本上一致，要求满足幂等设计。</li></ul><p>把上面的转账作为例子，通常会在Try里面冻结金额，但不扣款，Confirm里面扣款，Cancel里面解冻金额，一个成功完成的TCC事务时序图如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c033a1bda6370c72acb9874a396e9e31.png"></p><p><strong>TCC特点如下：</strong></p><ul><li>并发度较高，无长期资源锁定。</li><li>开发量较大，需要提供Try&#x2F;Confirm&#x2F;Cancel接口。</li><li>一致性较好，不会发生SAGA已扣款最后又转账失败的情况</li><li>TCC适用于订单类业务，对中间状态有约束的业务</li></ul><p>如果读者想要进一步研究TCC，go语言可参考DTM，java语言可参考seata</p><h3 id="◆-本地消息表"><a href="#◆-本地消息表" class="headerlink" title="◆ 本地消息表"></a><strong>◆</strong> 本地消息表</h3><p>本地消息表这个方案最初是 ebay 架构师 Dan Pritchett 在 2008 年发表给 ACM 的文章。设计核心是将需要分布式处理的任务通过消息的方式来异步确保执行。</p><p>大致流程如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/bdf9dc84d0f12be25a35b76749f7a437.png"></p><p>写本地消息和业务操作放在一个事务里，保证了业务和发消息的原子性，要么他们全都成功，要么全都失败。</p><p><strong>容错机制：</strong></p><ul><li>扣减余额事务 失败时，事务直接回滚，无后续步骤</li><li>轮序生产消息失败， 增加余额事务失败都会进行重试</li></ul><p><strong>本地消息表的特点：</strong></p><ul><li>长事务仅需要分拆成多个任务，使用简单</li><li>生产者需要额外的创建消息表</li><li>每个本地消息表都需要进行轮询</li><li>消费者的逻辑如果无法通过重试成功，那么还需要更多的机制，来回滚操作</li></ul><p>适用于可异步执行的业务，且后续操作无需回滚的业务</p><h3 id="◆-事务消息"><a href="#◆-事务消息" class="headerlink" title="◆ 事务消息"></a>◆ <strong>事务消息</strong></h3><p>在上述的本地消息表方案中，生产者需要额外创建消息表，还需要对本地消息表进行轮询，业务负担较重。阿里开源的RocketMQ 4.3之后的版本正式支持事务消息，该事务消息本质上是把本地消息表放到RocketMQ上，解决生产端的消息发送与本地事务执行的原子性问题。</p><p>事务消息发送及提交：</p><ul><li>发送消息（half消息）</li><li>服务端存储消息，并响应消息的写入结果</li><li>根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）</li><li>根据本地事务状态执行Commit或者Rollback（Commit操作发布消息，消息对消费者可见）</li></ul><p>正常发送的流程图如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/614098725240c67ba7ab3aee2c1ddb15.png"></p><p><strong>补偿流程：</strong></p><p>对没有Commit&#x2F;Rollback的事务消息（pending状态的消息），从服务端发起一次”回查”<br>Producer收到回查消息，返回消息对应的本地事务的状态，为Commit或者Rollback<br>事务消息方案与本地消息表机制非常类似，区别主要在于原先相关的本地表操作替换成了一个反查接口</p><p><strong>事务消息特点如下：</strong></p><ul><li>长事务仅需要分拆成多个任务，并提供一个反查接口，使用简单</li><li>消费者的逻辑如果无法通过重试成功，那么还需要更多的机制，来回滚操作</li></ul><p>适用于可异步执行的业务，且后续操作无需回滚的业务</p><p>如果读者想要进一步研究事务消息，可参考rocketmq，为了方便大家学习事务消息，DTM也提供了简单实现</p><h3 id="◆-最大努力通知"><a href="#◆-最大努力通知" class="headerlink" title="◆ 最大努力通知"></a><strong>◆</strong> <strong>最大努力通知</strong></h3><p>发起通知方通过一定的机制最大努力将业务处理结果通知到接收方。具体包括：</p><p>有一定的消息重复通知机制。因为接收通知方可能没有接收到通知，此时要有一定的机制对消息重复通知。<br>消息校对机制。如果尽最大努力也没有通知到接收方，或者接收方消费消息后要再次消费，此时可由接收方主动向通知方查询消息信息来满足需求。<br>前面介绍的的本地消息表和事务消息都属于可靠消息，与这里介绍的最大努力通知有什么不同？</p><p>可靠消息一致性，发起通知方需要保证将消息发出去，并且将消息发到接收通知方，消息的可靠性关键由发起通知方来保证。</p><p>最大努力通知，发起通知方尽最大的努力将业务处理结果通知为接收通知方，但是可能消息接收不到，此时需要接收通知方主动调用发起通知方的接口查询业务处理结果，通知的可靠性关键在接收通知方。</p><p><strong>解决方案上，最大努力通知需要：</strong></p><ul><li>提供接口，让接受通知放能够通过接口查询业务处理结果</li><li>消息队列ACK机制，消息队列按照间隔1min、5min、10min、30min、1h、2h、5h、10h的方式，逐步拉大通知间隔 ，直到达到通知要求的时间窗口上限。之后不再通知</li></ul><p>最大努力通知适用于业务通知类型，例如微信交易的结果，就是通过最大努力通知方式通知各个商户，既有回调通知，也有交易查询接口</p><h3 id="◆-AT事务模式"><a href="#◆-AT事务模式" class="headerlink" title="◆  AT事务模式"></a><strong>◆</strong>  AT事务模式</h3><p>这是阿里开源项目seata中的一种事务模式，在蚂蚁金服也被称为FMT。优点是该事务模式使用方式，类似XA模式，业务无需编写各类补偿操作，回滚由框架自动完成，缺点也类似AT，存在较长时间的锁，不满足高并发的场景。有兴趣的同学可以参考seata-AT</p><h3 id="◆-分布式事务中的网络异常"><a href="#◆-分布式事务中的网络异常" class="headerlink" title="◆ 分布式事务中的网络异常"></a><strong>◆</strong> <strong>分布式事务中的网络异常</strong></h3><p>在分布式事务的各个环节都有可能出现网络以及业务故障等问题，这些问题需要分布式事务的业务方做到防空回滚，幂等，防悬挂三个特性，下面以TCC事务说明这些异常情况：</p><p>空回滚：</p><p>在没有调用 TCC 资源 Try 方法的情况下，调用了二阶段的 Cancel 方法，Cancel 方法需要识别出这是一个空回滚，然后直接返回成功。</p><p>出现原因是当一个分支事务所在服务宕机或网络异常，分支事务调用记录为失败，这个时候其实是没有执行Try阶段，当故障恢复后，分布式事务进行回滚则会调用二阶段的Cancel方法，从而形成空回滚。</p><p>幂等：</p><p>由于任何一个请求都可能出现网络异常，出现重复请求，所以所有的分布式事务分支，都需要保证幂等性</p><p>悬挂：</p><p>悬挂就是对于一个分布式事务，其二阶段 Cancel 接口比 Try 接口先执行。</p><p>出现原因是在 RPC 调用分支事务try时，先注册分支事务，再执行RPC调用，如果此时 RPC 调用的网络发生拥堵，RPC 超时以后，TM就会通知RM回滚该分布式事务，可能回滚完成后，RPC 请求才到达参与者真正执行。</p><p>下面看一个网络异常的时序图，更好的理解上述几种问题</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c94ea718aca89549e4a3f53399d413cd.png"></p><p>业务处理请求4的时候，Cancel在Try之前执行，需要处理空回滚<br>业务处理请求6的时候，Cancel重复执行，需要幂等<br>业务处理请求8的时候，Try在Cancel后执行，需要处理悬挂</p><p>面对上述复杂的网络异常情况，目前看到各家建议的方案都是业务方通过唯一键，去查询相关联的操作是否已完成，如果已完成则直接返回成功。相关的判断逻辑较复杂，易出错，业务负担重。</p><p>在项目DTM中，出现了一种子事务屏障技术，使用该技术，能够达到这个效果，看示意图：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0c9d3034f184e61c06288f87639e3eea.png"></p><p>所有这些请求，到了子事务屏障后：不正常的请求，会被过滤；正常请求，通过屏障。开发者使用子事务屏障之后，前面所说的各种异常全部被妥善处理，业务开发人员只需要关注实际的业务逻辑，负担大大降低。<br>子事务屏障提供了方法ThroughBarrierCall，方法的原型为：</p><pre><code class="go">func ThroughBarrierCall(db *sql.DB, transInfo *TransInfo, busiCall BusiFunc)</code></pre><p>业务开发人员，在busiCall里面编写自己的相关逻辑，调用该函数。ThroughBarrierCall保证，在空回滚、悬挂等场景下，busiCall不会被调用；在业务被重复调用时，有幂等控制，保证只被提交一次。</p><p>子事务屏障会管理TCC、SAGA、XA、事务消息等，也可以扩展到其他领域</p><p>子事务屏障技术的原理是，在本地数据库，建立分支事务状态表sub_trans_barrier，唯一键为全局事务id-子事务id-子事务分支名称（try|confirm|cancel）</p><ul><li>开启事务</li><li>如果是Try分支，则那么insert ignore插入gid-branchid-try，如果成功插入，则调用屏障内逻辑</li><li>如果是Confirm分支，那么insert ignore插入gid-branchid-confirm，如果成功插入，则调用屏障内逻辑</li><li>如果是Cancel分支，那么insert ignore插入gid-branchid-try，再插入gid-branchid-cancel，如果try未插入并且cancel插入成功，则调用屏障内逻辑</li><li>屏障内逻辑返回成功，提交事务，返回成功</li><li>屏障内逻辑返回错误，回滚事务，返回错误</li></ul><p>在此机制下，解决了网络异常相关的问题</p><ul><li>空补偿控制–如果Try没有执行，直接执行了Cancel，那么Cancel插入gid-branchid-try会成功，不走屏障内的逻辑，保证了空补偿控制</li><li>幂等控制–任何一个分支都无法重复插入唯一键，保证了不会重复执行</li><li>防悬挂控制–Try在Cancel之后执行，那么插入的gid-branchid-try不成功，就不执行，保证了防悬挂控制</li></ul><p>对于SAGA事务，也是类似的机制。</p><p>子事务屏障技术，为DTM首创，它的意义在于设计简单易实现的算法，提供了简单易用的接口，在首创，它的意义在于设计简单易实现的算法，提供了简单易用的接口，在这两项的帮助下，开发人员彻底的从网络异常的处理中解放出来。</p><p>该技术目前需要搭配DTM事务管理器，目前SDK已经提供给go语言的开发者。其他语言的sdk正在规划中。对于其他的分布式事务框架，只要提供了合适的分布式事务信息，能够按照上述原理，快速实现该技术。</p><h3 id="◆-总结"><a href="#◆-总结" class="headerlink" title="◆ 总结"></a><strong>◆</strong> 总结</h3><p>本文介绍了分布式事务的一些基础理论，并对常用的分布式事务方案进行了讲解，在文章的后半部分还给出了事务异常的原因、分类以及优雅的解决方案。</p>]]></content>
      
      
      <categories>
          
          <category> 理论体系 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络七层模型</title>
      <link href="/2023/06/07/%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/%E7%BD%91%E7%BB%9C%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/06/07/%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/%E7%BD%91%E7%BB%9C%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="网络七层模型"><a href="#网络七层模型" class="headerlink" title="网络七层模型"></a>网络七层模型</h1><pre><code class="mermaid">graph LRA[物理层] --&gt; B[数据链路层] --&gt; C[网络层] --&gt; D[传输层] --&gt; E[会话层] --&gt; F[表示层] --&gt; G[应用层]G[应用层] --&gt; F[表示层] --&gt; E[会话层] --&gt; D[传输层] --&gt; C[网络层] --&gt; B[数据链路层] --&gt; A[物理层]</code></pre><pre><code class="mermaid">graph LRA[设备1] --&gt; |物理链路|B[设备2] --&gt; |物理链路|C[设备3] C --&gt;|物理链路| A</code></pre><pre><code class="mermaid">sequenceDiagram    participant 设备A    participant 设备B       设备A -&gt; 设备B: 1.物理链路层       设备A -&gt; 设备B: 2.数据链路层（基于物理链路，为数据提供可靠的数据传输，确认01的传输方式、顺序、速率）       设备A -&gt; 设备B: 3.网络层（建立两个设备之间的连接，IPV4 IPV6）    设备A -&gt; 设备B: 4.传输层（在网络层建立的通道中，选择一个门户，建立一个端口对端口的网络数据流服务管道）    设备A -&gt; 设备B: 5.会话层（创建完通讯管道之后，需要建立两端的会话，并且维护、终结等等）    设备A -&gt; 设备B: 6.表示层（在建立端口之后需要进行数据传递，分属不同设备，需要编译一个同意的公共编码，这层就是对数据编码）    设备A -&gt; 设备B: 7.应用层（包括但不限于HTTP、SMTP、FTP等等，为用户提供可使用的网络服务）</code></pre><ol><li>物理层<br>物理层负责将最后的信息编码转化成电流脉冲或者其他电信号用于传输，也就是对应的硬件支持</li><li>数据链路层<br>基于物理链路，为数据传输提供可靠的传输服务，对传输数据进行维护，数据帧的形式、传输的顺序、速率等等</li><li>网络层<br>确定源点和目标点的连接，可以理解为寻址</li><li>传输层<br>传输层向高层提供可靠的端口对端口的可靠传输服务</li><li>会话层<br>会话的建立、管理、终结表示层和实体之间的通信会话</li><li>表示层<br>为数据做编码和转化，确定数据的格式也就是表达形式，加密、编码</li><li>应用层<br>也就是我们所熟知的网络协议，包括但不限于HTTP、FTP、SMTP等</li></ol><hr><p><strong>1. 应用层:</strong> 应用层确定进程之间通信的性质，以满足用户的需要。应用层不仅要提供应用进程所需要的信息交换和远程操作，而且还要作为应用进程的用户代理，来完成一些为进行信息交换所必需的功能。</p><p><strong>2.表示层:</strong> 主要用于处理两个通信系统中交换信息的表示方式。为上层用户解决用户信息的语法问题。它包括数据格式交换、数据加密与<br>解密、数据压缩与终端类型的转换。</p><p><strong>3. 会话层:</strong> 在两个节点之间建立端连接。为端系统的应用程序之间提供了对话控制机制。此服务包括建立连接是以全双工还是以半双工的方式进行设置，尽管可以在层4中处理双工方式;会话层管理登入和注销过程。它具体管理两个用户和进程之间的对话。如果在某一时刻只允许一个用户执行一项特定的操作，会话层协议就会管理这些操作，如阻止两个用户同时更新数据库中的同一组数据。</p><p><strong>4. 传输层:</strong> 一堂规数据递送一面向连接或无连接，为会话展用户提供一个端到端的可靠，透明和优化的数据传输服务机制。包括全双工或半双工、流控制和错误恢复服务;传输层把消息分成若干个分组，并在接收端对它们进行重组。不同的分组可以通过不同的连接传送到主机。这样既能获得较高的带宽，又不影响会话层。在建立连接时传输层可以请求服务质量，该服务质量指定可接受的误码率、延迟量、安全性等参数，还可以实现基于端到端的流量控制功能。</p><p><strong>5. 网络层:</strong> 本层通过寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合话的路由和交换节点，正确无误地按照地址传送给目的端的运输层。它包括通过石连网络来路由和中继数据:除了选择路由之外，网络层还负责建立和维护连接，控制网络上的拥塞以及在必要的时候生成计费信息。常用设备有交换机。</p><p><strong>6. 数据链路层:</strong> 在此层将数据分帧，并外理流控制。屏蔽物理展，为网络层提供一个数据链路的连接，在一条有可能出差错的物理连接上，进行几乎无差错的数据传输(差错控制)。本层指定拓扑结构并提供硬件寻址。常用设备有网卡、网桥、交换机。</p><p><strong>7. 物理层:</strong> 处于OSI参考模型的最底层。物理层的主要功能是利用物理传输介质为数据链路层提供物理连接，以便透明的传送比特流。常<br>用设备有(各种物理设备)集线器、中继器、调制解调器、网线、双绞线、同轴电缆。</p>]]></content>
      
      
      <categories>
          
          <category> 理论体系 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络协议</title>
      <link href="/2023/06/07/%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/06/07/%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h1><p><strong>CDN</strong>：CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。</p><p>CDN(Content Delivery Network)是指内容分发网络，也称为内容传送网络，这个概念始于1996年，是美国麻省理工学院的一个研究小组为改善互联网的服务质量而提出的。为了能在传统IP网上发布丰富的宽带媒体内容，他们提出在现有互联网基础上建立一个内容分发平台专门为网站提供服务，并于1999年成立了专门的CDN服务公司，为Yahoo提供专业服务。由于CDN是为加快网络访问速度而被优化的网络覆盖层，因此被形象地称为“网络加速器”。</p>]]></content>
      
      
      <categories>
          
          <category> 理论体系 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python的Anaconda换源</title>
      <link href="/2023/06/07/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/Python%E7%9A%84Anaconda%E6%8D%A2%E6%BA%90/"/>
      <url>/2023/06/07/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/Python%E7%9A%84Anaconda%E6%8D%A2%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Anaconda-切换镜像源"><a href="#Anaconda-切换镜像源" class="headerlink" title="Anaconda 切换镜像源"></a>Anaconda 切换镜像源</h1><p>清华镜像源，由于https不通，只能将所有的链接全部换成http</p><pre><code class="yaml">channels:  - defaultsshow_channel_urls: truedefault_channels:  - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main  - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r  - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2custom_channels:  conda-forge: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  msys2: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  bioconda: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  menpo: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  pytorch: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  simpleitk: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</code></pre><p>基础命令</p><pre><code class="shell"># 创建虚拟环境conda crate -n py37 python=3.7# 激活环境，windows不用condaconda activate py37# 删除虚拟环境conda remove -n py37 --all</code></pre>]]></content>
      
      
      <categories>
          
          <category> 脚本语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Shell保留变量</title>
      <link href="/2023/06/07/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/Shell%E4%BF%9D%E7%95%99%E5%8F%98%E9%87%8F/"/>
      <url>/2023/06/07/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/Shell%E4%BF%9D%E7%95%99%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Shell保留变量"><a href="#Shell保留变量" class="headerlink" title="Shell保留变量"></a>Shell保留变量</h1><table><thead><tr><th>变量名</th><th>含义</th></tr></thead><tbody><tr><td>$IFS</td><td>这个变量中保存了用于分割输入参数的分割字符，默认识空格。</td></tr><tr><td>$HOME</td><td>这个变量中存储了当前用户的根目录路径。</td></tr><tr><td>$PATH</td><td>这个变量中存储了当前 Shell 的默认路径字符串。</td></tr><tr><td>$PS1</td><td>表示第一个系统提示符。</td></tr><tr><td>$PS2</td><td>表示第一个系统提示符。</td></tr><tr><td>$PWD</td><td>表示当前工作路径。</td></tr><tr><td>$EDITOR</td><td>表示系统的默认编辑器名称。</td></tr><tr><td>$BASH</td><td>表示当前 Shell 的路径字符串。</td></tr><tr><td>$0,$1…</td><td>表示系统传给脚本程序或脚本程序传给函数的第0个、第一个等参数。</td></tr><tr><td>$#</td><td>表示脚本程序的命令参数个数或函数的参数个数。</td></tr><tr><td>$$</td><td>表示该脚本程序的进程号，常用于生成文件名唯一的临时文件。</td></tr><tr><td>$?</td><td>表示脚本程序或函数的返回状态值，正常为 0，否则为非零的错误号。</td></tr><tr><td>$*</td><td>表示所有的脚本参数或函数参数。</td></tr><tr><td>$@</td><td>和 $* 涵义相似，但是比$* 更安全。</td></tr><tr><td>$!</td><td>表示最近一个在后台运行的进程的进程号。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 脚本语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Shell笔记</title>
      <link href="/2023/06/07/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/Shell%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/06/07/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/Shell%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Shell笔记"><a href="#Shell笔记" class="headerlink" title="Shell笔记"></a>Shell笔记</h1><pre><code class="shell"># 定义变量tipstips=&#39;Hello Word ！&#39;# 使用tips变量echo $&#123;tips&#125;# 设置为只读readonly tips# 删除变量unset tips</code></pre><p>选择器语法</p><pre><code class="shell"># 获取第一个参数，默认是从0开始，但是由于第0个是sh脚本名称所以从第一个开始param1=$1;case $param1 in  &#39;start&#39;)    echo &#39;service start ...&#39;;;  &#39;restart&#39;)    echo &#39;service restart ...&#39;;;    &#39;stop&#39;)      echo &#39;service stop ...&#39;;;    *)      echo &#39;comment not exists ...&#39;;;esac</code></pre><p>条件语法</p><pre><code class="shell">param=$1;if [[ param == &#39;start&#39; ]]; then  echo &#39;service start ...&#39;;fiif [[ param == &#39;start&#39; ]]; then  echo &#39;service start ...&#39;;elif [[ param == &#39;restart&#39; ]]; then  echo &#39;service restart ...&#39;;  fi</code></pre><p>循环语法</p><pre><code class="shell">param1=$1;while [[ condition ]]; do  echo &quot;----$param1----&quot;;  let &quot;param1-=1&quot;;donefor (( i = 0; i &lt; 10; i++ )); do  #statementsdone</code></pre><p><strong>要点</strong></p><ol><li>shell的变量定义为直接定义，变量名与内容之间不能有空格</li><li>使用变量的时候，需要使用美元符号，可以用花括号括起来，也可以不用，主要是为了区分边界</li><li>readonly设置变量为只读模式，其后不可再赋值，只能读取</li><li>unset删除指定变量</li><li>shell语法需要注意单引号和双引号，单引号的字符串内不能再使用相关变量，而双引号可以</li><li>变量赋值方式 let variable&#x3D;variable+1;  let “variable++”; ((variable++))</li></ol>]]></content>
      
      
      <categories>
          
          <category> 脚本语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker初步使用</title>
      <link href="/2023/06/07/%E8%99%9A%E6%8B%9F%E5%AE%B9%E5%99%A8/Docker%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/06/07/%E8%99%9A%E6%8B%9F%E5%AE%B9%E5%99%A8/Docker%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="docker初步使用"><a href="#docker初步使用" class="headerlink" title="docker初步使用"></a>docker初步使用</h1><p>命令解析</p><pre><code class="shell">docker run ubuntu:15.10 /bin/echo &quot;Hello Word&quot;</code></pre><ul><li><code>docker</code>Docker的二进制执行文件</li><li><code>run </code>与docker组合来运行一个容器</li><li><code>ubuntu:15.10</code>指定需要运行的镜像，docker首先在本地查找是否有该镜像，如果没有的话就将从镜像库中获取对应的镜像</li><li><code>/bin/echo &quot;Hellow Word&quot;</code>在启动的容器中执行的命令</li></ul><p>交互式容器的运行</p><pre><code class="shell">docker run -it ubuntu:15.10 /bin/bash</code></pre><ul><li><code>-i</code>运行对容器内的标准输入（STDIN）进行交互</li><li><code>-t</code>在新的容器内指定一个伪终端或者终端</li></ul>]]></content>
      
      
      <categories>
          
          <category> 虚拟容器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker的常用命令</title>
      <link href="/2023/06/07/%E8%99%9A%E6%8B%9F%E5%AE%B9%E5%99%A8/Docker%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/06/07/%E8%99%9A%E6%8B%9F%E5%AE%B9%E5%99%A8/Docker%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="docker的常用命令"><a href="#docker的常用命令" class="headerlink" title="docker的常用命令"></a>docker的常用命令</h1><p>容器的创建</p><pre><code class="shell">docker run -i ubuntu:15.10 </code></pre><p>创建后台运行容器</p><pre><code class="shell">docker run -itd [--name specified_name] ubuntu /bin/bash</code></pre><ul><li><code>docker</code>Docker的二进制执行文件</li><li><code>run </code>与docker组合来运行一个容器</li><li><code>/bin/bash</code>放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 &#x2F;bin&#x2F;bash</li><li><code>-t:</code>终端</li><li><code>-i:</code>交互式操作</li><li><code>-d:</code> 参数默认不会进入容器，想要进入容器需要使用指令 <strong>docker exec</strong></li><li><code>ubuntu:15.10</code>指定需要运行的镜像，docker首先在本地查找是否有该镜像，如果没有的话就将从镜像库中获取对应的镜像</li></ul><p>查看所有容器</p><pre><code class="shell">docker ps -a</code></pre><p>启动容器</p><pre><code class="shell">docker start [mirror_name or mirror_id]</code></pre><p>停止容器</p><pre><code class="shell">docker stop [docker_name or docker_id]</code></pre><p>删除容器</p><pre><code class="shell">docker rm [specifind_name or specifind_id]</code></pre><hr><p>镜像获取</p><pre><code class="shell">docker pull [mirror_name]</code></pre><p>进入容器</p><pre><code class="shell">docker exec -it [specifind_name or specifind_id] /bin/bashdocker attach [specifind_name or specifind_id]</code></pre><ul><li><code>exec:</code>此退出容器终端，不会导致容器的停止，推荐使用</li></ul><p>导出容器</p><pre><code class="shell">docker export [specifind_name or specifind_id] &gt; ubuntu.tar</code></pre><p>导入容器快照</p><pre><code class="shell">cat ubuntu.tar | docker import - test/ubuntu:v1</code></pre><p>通过URL导入快照</p><pre><code class="shell"> docker import http://example.com/exampleimage.tgz example/imagerepo</code></pre><p><img src="http://www.ajiehome.cn/wp-content/uploads/2021/03/docker%E7%9A%84%E6%89%80%E6%9C%89%E9%95%9C%E5%83%8F.png"></p><p>载入镜像</p><pre><code class="shell">docker pull training/webapp</code></pre><p>运行镜像程序</p><pre><code class="shell">docker run -d -P training/webapp python app.py</code></pre><ul><li><code>-d:</code>让容器在后台运行。</li><li><code>-P:</code>将容器内部使用的网络端口随机映射到我们使用的主机上</li></ul><p><img src="http://www.ajiehome.cn/wp-content/uploads/2021/03/webapp%E8%BF%90%E8%A1%8C%E5%9B%BE.png"></p><p><strong>PORTS</strong></p><ul><li><code>0.0.0.0:49153-&gt;5000:</code>表明docker开放了5000端口，映射到了本地的49153端口</li></ul>]]></content>
      
      
      <categories>
          
          <category> 虚拟容器 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
